#line 69 "library.nw"
/* This was a literate program.  library.nw is the original source,
   from which library.c was generated by `notangle' and from which
   printable LaTeX can be produced by `noweave' if you have those
   tools. */
#line 124 "library.nw"
#if F2C
/* #  define KNOWN_MACHINE */
#  define CALL_LIKE_SUN 1
#line 132 "library.nw"
#else
#if defined (_AIX)
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#line 139 "library.nw"
#if defined (alliant)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 146 "library.nw"
#if defined (ardent) || defined (titan)
#  ifndef stardent
#    define stardent
#  endif
#endif
#if defined (stardent)
#  define KNOWN_MACHINE
#  define CALL_LIKE_STARDENT 1
#endif
#line 161 "library.nw"
#if defined (__convex__) || defined (__convexc__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 170 "library.nw"
#if defined (ESV)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 177 "library.nw"
#if defined (__hpux) 
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#line 184 "library.nw"
#if defined (iris)
#  define KNOWN_MACHINE
#  define CALL_LIKE_IRIS 1
#endif
#line 192 "library.nw"
#ifdef __sgi   /* in ANSI mode */
#  ifndef sgi
#    define sgi
#  endif
#endif
#if defined (sgi)                     /* Silicon graphics with R3000's */
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 203 "library.nw"
#if defined (solbourne) 
#  ifndef sun
#   define sun               /* don't know whether it's defined or not */
#  endif
#endif
#line 209 "library.nw"
#if defined (sun)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#  define strerror(i) sys_errlist[i] /* k&r compiler doesn't have it */
#endif
#line 219 "library.nw"
#if defined (ultrix) || defined(__OSF1__) || defined(__osf__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 225 "library.nw"
#if defined (VMS)
#  define KNOWN_MACHINE
#endif
#endif /* F2C */
#line 234 "library.nw"
#if ! defined (KNOWN_MACHINE)
  #error System type is not known -- see the Installation Guide
#else
#line 255 "library.nw"
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE
#endif
#line 259 "library.nw"
#include <stdio.h>

#if defined (VMS)
#  include <descrip.h>          /* non-POSIX */
#  define NOUNISTD
#else
#  include <sys/types.h>
#  include <sys/times.h>
#endif

#ifdef stardent                 /* who knows if this works anyhow... */
#  include <sys/types.h>
#  include <malloc.h>           /* non-POSIX */
#else
#  include <stddef.h>
#endif
#line 278 "library.nw"
#include <string.h>
#line 282 "library.nw"
#ifndef NOUNISTD
#  include <unistd.h>
#  include <stdlib.h> 
#else
#  ifndef VMS
#    include <sys/file.h>       /* ESV, old Concentrix */ /* non-POSIX */
#  endif
#  endif

#include <errno.h>
#  include <ctype.h>

#ifdef _AIX                     /* would do no harm on others, though */
#  include <time.h>
#endif
#line 303 "library.nw"
#define MAXFLEN       500       /* the maximum length of a filename in CCP4 */
#define MAXFILES       10    /* maximum number of files open symultaneously */
#define DEFSIZE         2    /* default mode access for random access files */
#line 309 "library.nw"
#define IRRELEVANT_OP   0      /* used to show if an fseek is needed or not */
#define READ_OP         1
#define WRITE_OP        2
#line 317 "library.nw"
#ifndef SEEK_SET
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
#endif /* ! SEEK_SET */
#line 323 "library.nw"
#if defined (VMS)
#  define DELFILE remove
#else
#  define DELFILE unlink
#endif

#if defined (ardent) || defined (titan) || defined (stardent)
  struct Str_Desc {
    char *Str_pointer;
    int  Str_length;
    int id;
  };
#endif
#line 342 "library.nw"
#define BYTE  0
#define INT16 1   
#define INT32 6
#define FLOAT32 2
#define COMP32  3
#define COMP64  4

#line 1219 "library.nw"
/* class info codes for int */
#define DFNTI_MBO       1       /* Motorola byte order 2's compl */
#define DFNTI_IBO       4       /* Intel byte order 2's compl */

/* class info codes for float */
#define DFNTF_BEIEEE    1       /* big endian IEEE (canonical) */
#define DFNTF_VAX       2       /* Vax format */
#define DFNTF_CONVEXNATIVE 5    /* Convex native floats */
#define DFNTF_LEIEEE    4       /* little-endian IEEE format */

#line 1231 "library.nw"
#define DFMT_BEIEEE             0x11110000 /* bigendian IEEE (canonical) */
#define DFMT_LEIEEE             0x00004441 /* little endian IEEE */
#define DFMT_VAX                0x00004122 /* VAX (not Alpha) */
#define DFMT_VP                 0x66110000 /* IBM clone */
#define DFMT_CONVEXNATIVE       0x55110000 /* Convex without IEEE unit */

#line 1243 "library.nw"
#ifdef VAX
#  define DF_MT   DFMT_VAX
#endif
#line 1252 "library.nw"
#if defined(MIPSEL) || defined(alliant) || defined(__ALPHA) || defined(i386)
#  define DF_MT   DFMT_LEIEEE
#endif
#line 1260 "library.nw"
/* the VAX VMS compiler objected to splitting this line */
#if defined(MIPSEB) || defined(__hpux) || defined(_AIX) || defined(m68k) || defined(mc68000) || defined(sparc)
#  define DF_MT   DFMT_BEIEEE
#endif
#line 1266 "library.nw"
#if defined(convex) || defined(__convex__)
#  ifdef _IEEE_FLOAT_
#    define DF_MT DFMT_BEIEEE
#  else
#    ifdef _CONVEX_FLOAT_
#      define DF_MT DFMT_CONVEXNATIVE
#    else
       #error "Can't determine Convex floating point type (use native compiler)"
#    endif
#  endif
#endif

#ifndef DF_MT
  #error "Can't determine DF_MT (machine number format)"
#endif
#line 1283 "library.nw"
#define DFNT_UINT       0       /* unsigned int */
#define DFNT_SINT       1       /* short int */
#define DFNT_INT        2       /* int */
#define DFNT_UCHAR      3       /* unsigned char */
#define DFNT_CHAR       4       /* char */
#define DFNT_FLOAT      5       /* float */
#define DFNT_DOUBLE     6       /* double */
#define map_stamp_posn  208L    /* machine stamp offset in map header */
#define mt_stamp_posn   8L      /* machine stamp offset in MTZ header */
#line 352 "library.nw"
static char rcsid[] = "$Id$";
static int initialised =  0;    /* flag to initialise data and file streams */
static char *file_attribute[] = {"w+", "w+", "r+", "w+", "r"};/* file modes */
#line 361 "library.nw"
static int item_sizes[] = {
  (int) sizeof (char),                                          /* 0: bytes */
#if defined (sgi)
  (int) sizeof (short),         /* silicon graphics bodge (This is fixed in
                                   IRIX4, at least) */
#else
  (int) sizeof (short int),                      /* 1: (integer) half words */
#endif
  (int) sizeof (float),                                   /* 2: reals/words */
  (int) sizeof (int),           /* 3: `short complex' (pairs of half words).
                                   NB int rather than 2*short since must fit
                                   into fortran integer */
  (int) 2*sizeof (float),                    /* 4: complex (pairs of words) */
  (int) sizeof (int),           /* 5: not used */
  (int) sizeof (int)            /* 6: integers */
};
#line 380 "library.nw"
static FILE *file_stream[MAXFILES];                 /* Pointer to disk file */
static char file_name[MAXFILES][MAXFLEN];      /* Pointer to disk file name */
static int  file_bytes_per_item[MAXFILES];/* Pointer to disk file item size */
static int  file_is_scratch[MAXFILES];    /* Indicates if file is 'SCRATCH' */
static int  file_last_op [MAXFILES];    /* see man fopen rd/wr combinations */
static int file_mode[MAXFILES];               /* diskio mode of each stream */
#line 1293 "library.nw"
typedef short int16;
typedef unsigned long uint32;
typedef float float32;
typedef unsigned char uint8;

union float_uint_uchar {
    float32 f;
    uint32 i;
    uint8 c[4]; };
#if DF_MT == DFMT_BEIEEE
static int16 userIT = (int16) DFNTI_MBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_BEIEEE; /* machine float type */
#endif
#if DF_MT == DFMT_LEIEEE
static int16 userIT = (int16) DFNTI_IBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_LEIEEE; /* machine float type */
#endif
#if DF_MT == DFMT_VAX
static int16 userIT = (int16) DFNTI_IBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_VAX; /* machine float type */
#endif
#if DF_MT == DFMT_CONVEXNATIVE
static int16 userIT = (int16) DFNTI_MBO; /* machine integer type */ 
static int16 userFT = (int16) DFMT_CONVEXNATIVE; /* machine float type */
#endif
static int
    Iconvert[MAXFILES],         /* integer convserion needed on read*/
    Fconvert[MAXFILES];         /* real convserion needed on read*/
static char fileType[MAXFILES][4]; /* MAP/MTZ stamp */
#line 394 "library.nw"
static size_t flength (s, len)
char *s;
int len;
{
  while (s[--len] == ' ');
  return (++len);
}
#line 404 "library.nw"
static void fatal (message)
char *message;
{
  int one = 1;
  int *code = &one;
  int length = strlen(message);
#if CALL_LIKE_HPUX
  extern void ccperr();

  ccperr (code, message, length);
#endif
#if CALL_LIKE_STARDENT
  extern void CCPERR();
  struct Str_Desc *str;

  str->Str_length = length;
  str->Str_pointer = message;
  (void) strncpy (str->Str_pointer, message, length);
  CCPERR (code, str);
#endif
#if defined (VMS)
  extern void CCPERR();
   struct dsc$descriptor_s *str;

   str->dsc$a_pointer = message;
   str->dsc$w_length = length;
  CCPERR (code, str);
#endif
#if CALL_LIKE_SUN
  extern void ccperr_();

  ccperr_ (code, message, length);
#endif
#if CALL_LIKE_IRIS
  extern fortran ccperr_();

  (void) ccperr_ (length, code, message);
#endif
 }
#line 1397 "library.nw"
static void vaxF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[1] << 1) | (buffer[i].c[0] >> 7); /* extract exponent */
    if (!exp && !buffer[i].c[1])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[1] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[0];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    } else if (exp) {           /* denormalized number */
      int shft;

      out.c[0] = buffer[i].c[1] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[0] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[0] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
      out.c[3] = (uint8)(buffer[i].c[3] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[0] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    }
    buffer[i] = out;            /* copy back result */
  }
}

static void ieeeF2vaxF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i<size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[0] = buffer[i].c[1];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[0] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[1] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[0] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[3] << shft);
      out.c[1] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[1] |= 0x01;
        out.c[0] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
#line 1489 "library.nw"
static void convexF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (!exp && !buffer[i].c[0])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[0] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    } else if (exp) {           /* denormalized number */
      int shft;
      
      out.c[0] = buffer[i].c[0] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[1] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[1] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
      out.c[3] = (uint8)(buffer[i].c[2] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[1] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    }
    buffer[i] = out;            /* copy back result */
  }
}

static void ieeeF2convexF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i < size; i++) {
    exp = (uint8)(buffer[i].c[0] << 1) |
      (uint8)(buffer[i].c[1] >> 7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[3] = buffer[i].c[3];
      out.c[2] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[1] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[0] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[1] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[3] << shft);
      out.c[0] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[0] |= 0x01;
        out.c[1] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
#line 455 "library.nw"
#if ! defined (VMS)

#if CALL_LIKE_HPUX
  void ustenv (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_STARDENT
  void USTENV (str, result)
  struct Str_Desc *str;
#endif
#if CALL_LIKE_SUN
  void ustenv_ (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_IRIS
  fortran ustenv_ (Lstr, str, result)
  char *str;
  int  Lstr;
#endif

int *result;
{
  size_t Length;
  char name[MAXFLEN], value[MAXFLEN], *temp;

#if CALL_LIKE_STARDENT
  Length = flength (str->Str_pointer, str->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str->Str_pointer, Length);
#else
  Length = flength (str, Lstr);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str, Length);
#endif
  name[Length] = '\0'; 

#if defined (sgi) || defined (sun) || defined (__hpux) || \
    defined(_AIX) || defined(ultrix)
      /* putenv is the POSIX.1, draft 3 proposed mechanism */
      /* ESV seems to have it in the SysVile universe */
  temp = (char *) malloc (MAXFLEN);
  if (temp == NULL) fatal("USTENV: Memory allocation failed");
  (void) strcpy (temp, name);
  *result = putenv (temp);
  /* note the necessary lack of free() */
#else
  /* setenv is not POSIX */
  temp = (char *) strchr (name, '='); /* BSD might have to use `index' */
  if (temp != NULL) {
    *temp = '\0';
    temp++;
    (void) strcpy (value, temp);
  };
  *result = setenv (name, value, 1);
#endif
}

#endif  /* end of #if ! defined (VMS) */
#line 520 "library.nw"
#if CALL_LIKE_HPUX
  void cunlink (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void CUNLINK (filename)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void CUNLINK (filename)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void cunlink_ (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran cunlink_ (Lfilename, filename)
  char *filename;
  int  Lfilename;
#endif
{
  size_t Length;
  char tempfile[MAXFLEN];

#if CALL_LIKE_STARDENT
    Length = flength (filename->Str_pointer, filename->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->Str_pointer, Length);
#else
#  if ! defined (VMS)
    Length = flength (filename, Lfilename);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename, Length);
#  else
    Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->dsc$a_pointer, Length);
#  endif
    tempfile[Length] = '\0';
    if (DELFILE (tempfile) != 0)
      fatal("Can\'t unlink");
#endif
}
#line 568 "library.nw"
#if CALL_LIKE_HPUX
  void copen (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void COPEN (iunit, filename, istat)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void COPEN (iunit, filename, istat)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void copen_ (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran copen_ (iunit, Lfilename, filename, istat)
  char *filename;
  int  Lfilename;
#endif

int  *iunit, *istat;
{
  size_t Length;
  int i, jstat;
  int16 fileFT, fileIT;         /* machine type stamps in file */
  unsigned char mtstring[2];    /* machine stamp */

  jstat = *istat;
  if (! initialised) {
    /* note that array element 0 is unused -- using it produced
       complaints from mtzlib about a zero stream */
    for (i = 1; i < MAXFILES; i++) {
      file_stream[i]         = NULL;
      file_name[i][0]        = '\0';
      file_bytes_per_item[i] = item_sizes[DEFSIZE];  /* default item size */
      file_is_scratch[i]     = 0;
      file_last_op[i]        = IRRELEVANT_OP;
    }
    initialised = 1;
  }
  for (i = 1; i < MAXFILES; i++) /* Find next available stream */
    if (file_stream[i] == NULL) break;
  if (i == MAXFILES) {
    *iunit = -1;                /* return no more units flag */
    return;
  } else {
    *iunit = i;}                 /* will return the stream number */
#if CALL_LIKE_STARDENT
  Length = flength (filename->Str_pointer, filename->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->Str_pointer, Length);
#else
#  if defined (VMS)
  Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->dsc$a_pointer, Length);
#  else
  Length = flength (filename, Lfilename);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename, Length);
#  endif
#endif
  file_name[i][Length] = '\0';
  file_last_op[i] = IRRELEVANT_OP;
  file_bytes_per_item[i] = item_sizes[DEFSIZE]; /* default item size */
  file_is_scratch[i] = (jstat == 2);
  file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1]);
  if (file_stream[i] == NULL) {
    i = -2;                     /* return open failure flag */
    return; }
  if (file_is_scratch[i] && DELFILE (file_name[i])!=0)
      fatal ("(Q)QOPEN: error unlinking scratch file");
  
#line 659 "library.nw"
Fconvert[*iunit] = Iconvert[*iunit] = 0;
fileFT = fileIT =0;
if ((*file_attribute[*istat - 1] != 'w') &&
    (! file_is_scratch[*iunit]) &&
    (fread (fileType[*iunit], (size_t) sizeof(char), (size_t) 4,
            file_stream[*iunit]) == 4))
{
  if (strncmp (fileType[*iunit],"MTZ",3) == 0) { /* MTZ file? */
    if ((fseek (file_stream[*iunit], mt_stamp_posn, SEEK_SET) == 0)
        && (fread (mtstring,(size_t)  sizeof(char), (size_t) 2,
                   file_stream[*iunit]) == 2)) {
    } else {
      fatal("(Q)QOPEN: can't read machine stamp in MTZ file");}
  } else {                      /* map file? */
    if (fseek (file_stream[*iunit], map_stamp_posn, SEEK_SET)==0 &&
        (fread (fileType[*iunit], (size_t) sizeof(char), (size_t) 4,
                file_stream[*iunit]) == 4) &&
        (strncmp(fileType[*iunit],"MAP",3) == 0)) {
      if (fread (mtstring, (size_t) sizeof(char), (size_t) 2,
                 file_stream[*iunit]) != 2)
        fatal("(Q)QOPEN: can't read machine stamp in map file");
    }
  }
}
errno = 0;                    /* in case of unchecked i/o error above */
fileIT = (mtstring[1]>>4) & 0x0f;
fileFT = (mtstring[0]>>4) & 0x0f;
/* Record the need for conversion and what the file type is: */
if (fileFT != 0 && fileFT != userFT)
     Fconvert[*iunit] = fileFT;  /* else assume native */
if (fileIT != 0 && fileIT != userIT)
     Iconvert[*iunit] = fileIT;  /* else assume native */
#line 645 "library.nw"
  if (fseek (file_stream[*iunit], 0L, SEEK_SET) != 0)
    fatal("(Q)QOPEN: fseek failed");
  *iunit = i;
}
#line 694 "library.nw"
#if CALL_LIKE_HPUX
  void qclose (iunit)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QCLOSE (iunit)
#endif
#if CALL_LIKE_SUN
  void qclose_ (iunit)
#endif
#if CALL_LIKE_IRIS
  fortran qclose_ (iunit)
#endif

int *iunit;
{
  if (! initialised) 
    fatal ("QCLOSE: qopen/qqopen not yet called");

  if (file_stream[*iunit] != NULL) {
    if (fclose (file_stream[*iunit]) == EOF) 
      fatal ("QCLOSE: failed"); /* fixme: add file name to message */
    file_stream[*iunit] = NULL;
  }
  file_name[*iunit][0] = '\0';
}
#line 727 "library.nw"
#if CALL_LIKE_HPUX
  void qmode (iunit, mode, size)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QMODE (iunit, mode, size)
#endif
#if CALL_LIKE_SUN
  void qmode_ (iunit, mode, size)
#endif
#if CALL_LIKE_IRIS
  fortran qmode_ (iunit, mode, size)
#endif

int *iunit, *mode, *size;
{
  if (! initialised) 
    fatal ("QMODE: qopen/qqopen not yet called");

  if (*mode >= 0 && *mode <= 6 && *mode != 5)
    file_bytes_per_item[*iunit] = item_sizes[*mode];
  else
    fatal ("QMODE: bad mode");
  *size = file_bytes_per_item[*iunit];       /* return number of bytes/item */
  file_mode[*iunit] = *mode;
}
#line 761 "library.nw"
#if CALL_LIKE_HPUX
  void qread (iunit, buffer, nitems, result)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QREAD (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_SUN
  void qread_ (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_IRIS
  fortran qread_ (iunit, buffer, nitems, result)
#endif

uint8 * buffer;
int *iunit, *nitems, *result;
{
  int i, nbytes, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP &&
      fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      *result = -1;
      return;
    }
  file_last_op[*iunit] = READ_OP;
  nbytes = *nitems * file_bytes_per_item[*iunit];
  i = fread (buffer, (size_t) file_bytes_per_item[*iunit], 
                (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) {
    if (i == 0) *result = -1;   /* fixme: should use feof */
    else *result = i;
    return;
  }
  *result = 0;
  n = *nitems;
  switch (file_mode[*iunit]) {
  case BYTE:
    break;
  case INT16:
    if (Iconvert[*iunit])
      
#line 1324 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && userIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && userIT==DFNTI_MBO)) {
  char j;
  for (i=0; i < n*2; i+=2) {
    j = buffer[i];
    buffer[i] = buffer[i+1];
    buffer[i+1] = j; } }
else
  fatal("QREAD: bad file type in conversion");
}
#line 803 "library.nw"
    break;
  case INT32:
    if (Iconvert[*iunit])
      
#line 1336 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && userIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && userIT==DFNTI_MBO))
  
#line 1381 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1340 "library.nw"
else
  fatal("QREAD: bad file type in conversion");
}
#line 807 "library.nw"
    break;
  case FLOAT32:
    if (Fconvert[*iunit])
      
#line 1345 "library.nw"
{
switch (Fconvert[*iunit]) {     /* get to BE IEEE */
   case DFNTF_VAX :
     vaxF2ieeeF(buffer, n);
     break;   
   case DFNTF_CONVEXNATIVE :
     convexF2ieeeF(buffer, n);
     break;
   case DFNTF_BEIEEE :
     break;
   case DFNTF_LEIEEE :
     
#line 1381 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1357 "library.nw"
     break;
   default :
     fatal("QREAD: bad file type in conversion");
   }
#line 1364 "library.nw"
switch (userFT) {
  case DFNTF_BEIEEE :
    break;                      /* done enough */
  case DFNTF_LEIEEE :
    
#line 1381 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1369 "library.nw"
    break;
  case DFNTF_CONVEXNATIVE :
    ieeeF2convexF(buffer, n);
    break;
  case DFNTF_VAX :
    ieeeF2vaxF(buffer, n);
    break;
  default :
    fatal("QREAD: bad native type in conversion");
  }
}
#line 811 "library.nw"
    break;
  case COMP32:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of ints */
      
#line 1324 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && userIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && userIT==DFNTI_MBO)) {
  char j;
  for (i=0; i < n*2; i+=2) {
    j = buffer[i];
    buffer[i] = buffer[i+1];
    buffer[i+1] = j; } }
else
  fatal("QREAD: bad file type in conversion");
}
#line 816 "library.nw"
    }
    break;
  case COMP64:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of reals */
      
#line 1345 "library.nw"
{
switch (Fconvert[*iunit]) {     /* get to BE IEEE */
   case DFNTF_VAX :
     vaxF2ieeeF(buffer, n);
     break;   
   case DFNTF_CONVEXNATIVE :
     convexF2ieeeF(buffer, n);
     break;
   case DFNTF_BEIEEE :
     break;
   case DFNTF_LEIEEE :
     
#line 1381 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1357 "library.nw"
     break;
   default :
     fatal("QREAD: bad file type in conversion");
   }
#line 1364 "library.nw"
switch (userFT) {
  case DFNTF_BEIEEE :
    break;                      /* done enough */
  case DFNTF_LEIEEE :
    
#line 1381 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1369 "library.nw"
    break;
  case DFNTF_CONVEXNATIVE :
    ieeeF2convexF(buffer, n);
    break;
  case DFNTF_VAX :
    ieeeF2vaxF(buffer, n);
    break;
  default :
    fatal("QREAD: bad native type in conversion");
  }
}
#line 822 "library.nw"
    }
    break;
  default:
    fatal ("QREAD: Bad mode");
  }
}
#line 833 "library.nw"
#if CALL_LIKE_HPUX
  void qwrite (iunit, buffer, nitems)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QWRITE (iunit, buffer, nitems)
#endif
#if CALL_LIKE_SUN
  void qwrite_ (iunit, buffer, nitems)
#endif
#if CALL_LIKE_IRIS
  fortran qwrite_ (iunit, buffer, nitems)
#endif
uint8 * buffer;
int *iunit, *nitems;
{
  int i;

  if (! initialised) 
    fatal ("QWRITE: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP)
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITE: i/o error");
  file_last_op[*iunit] = WRITE_OP;
  i = (int) fwrite (buffer, (size_t) file_bytes_per_item[*iunit],
                    (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) fatal ("QWRITE: i/o error");
}

/****************************************************************************
 * Routine: qseek                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qseek (iunit, irecl, iel, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QSEEK (iunit, irecl, iel, lrecl)
#endif
#if CALL_LIKE_SUN
  void qseek_ (iunit, irecl, iel, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qseek_ (iunit, irecl, iel, lrecl)
#endif

int *iunit, *irecl, *iel, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSEEK: qopen/qqopen not yet called");
  position = (long) ((*lrecl)*(*irecl - 1) + (*iel - 1));
  position *= (long) file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSEEK failed");     /* fixme: add file info */
} /* End of qseek */

/****************************************************************************
 * Routine: qback                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qback (iunit, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QBACK (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qback_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qback_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QBACK: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) - (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit], position, SEEK_SET) != 0)
    fatal ("QBACK failed");     /* fixme: add file info */
}

/****************************************************************************
 * Routine: qskip                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qskip (iunit, lrecl)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QSKIP (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qskip_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qskip_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSKIP: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) +
    (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSKIP failed");     /* fixme: add file info */
}

/****************************************************************************
 * Routine: cqinq                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void cqinq (iunit, filnam, length, len_filnam)
  char *filnam; 
  int len_filnam;
#endif
#if CALL_LIKE_STARDENT
  void CQINQ (iunit, filnam, length)
  struct Str_Desc *filnam;
#endif
#if defined (VMS)
  void CQINQ (iunit, filnam, length)
  struct dsc$descriptor_s *filnam;
#endif
#if CALL_LIKE_SUN
  void cqinq_ (iunit, filnam, length, len_filnam)
  char *filnam;
  int len_filnam;
#endif
#if CALL_LIKE_IRIS
  fortran cqinq_ (iunit, len_filnam, filnam, length)
  char *filnam;
  int len_filnam;
#endif

int *iunit, *length;
{
  char real_name[MAXFLEN];
  int stream, Length, i;
  long position;

  if (! initialised) 
    fatal ("QQINQ:,qopen/qqopen not yet called");
  *length = -1;                                    /* default return value */
  stream = *iunit;
  if (file_stream[stream] == NULL) { 
    /* no unit open -- try file name */
#if CALL_LIKE_STARDENT
    Length = flength (filnam->Str_pointer, filnam->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (real_name, filnam->Str_pointer, Length);
#else
#  if defined (VMS)
     Length = flength (filnam->dsc$a_pointer, filnam->dsc$w_length);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam->dsc$a_pointer, Length);
#  else
     Length = flength (filnam, len_filnam);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam, Length);
#  endif
#endif
    real_name[Length] = '\0';
    for (i = 1; i < MAXFILES; i++)
      if (! strcmp (real_name, file_name[i])) break;
    stream = i % MAXFILES;
  }
  if (file_stream[stream] != NULL) {
    file_last_op[stream] = IRRELEVANT_OP;
    (void) fflush (file_stream[stream]);               /* flush the output stream */
#if 0
    /* checking the return value reportedly causes problems in ultrix
       under unknown circumstances... */
    if (fflush (file_stream[stream]) != 0) fatal ("QQINQ: flush failed");
#endif
    position = ftell (file_stream[stream]);   /* remember current position */
    (void) fseek (file_stream[stream],0L,SEEK_END); /* seek EOF */
    *length = (int) ftell (file_stream[stream]); /* get file size */
    if (fseek (file_stream[stream],position,SEEK_SET) != 0) /* seek position */
      fatal ("QQINQ: seek failed"); /* fixme: add file info */
  }
} /* End of cqinq */

/****************************************************************************
 * Routine: qlocate                                                         *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qlocate (iunit, locate)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QLOCATE (iunit, locate)
#endif
#if CALL_LIKE_SUN
  void qlocate_ (iunit, locate)
#endif
#if CALL_LIKE_IRIS
  fortran qlocate_ (iunit, locate)
#endif

int *iunit, *locate;
{
  if (! initialised) 
    fatal ("QLOCATE: qopen/qqopen not yet called");
  *locate = -1;
  if (file_stream[*iunit] != NULL)
    *locate = (int) ftell (file_stream[*iunit]) / file_bytes_per_item[*iunit];
} /* End of qlocate */

/****************************************************************************
 * Routine: qtype                                                          *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qtype (istamp)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QTYPE (istamp)
#endif
#if CALL_LIKE_SUN
  void qtype_ (istamp)
#endif
#if CALL_LIKE_IRIS
  fortran qtype_ (istamp)
#endif
  int *istamp;
{
  *istamp = DF_MT;
}
#line 1077 "library.nw"
#ifdef _AIX
void idate (d, m, y)
     int *y, *m, *d;
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     *y = lt->tm_year + 1000; *m = lt->tm_mon; *d = lt->tm_mday;
}
#endif                          /* _AIX */

#line 1090 "library.nw"
#if defined (__hpux) || defined (_AIX)
void gerror (str, Lstr)
char *str;
int  Lstr;
{
  int i;

  if (errno == 0) {             /* Avoid `Error 0' or some such message */
    for (i=1; Lstr; i++)
      str[i] = ' ';
  } else {
    (void) strncpy (str, strerror (errno), Lstr);
    for (i = strlen (str); i < Lstr; i++) str[i] = ' ';  /* pad with spaces */
  }
} /* End of gerror (str, Lstr) */

int ierrno () {
  return errno;
}

void itime (array)
     int array[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     array[0] = lt->tm_hour; array[1] = lt->tm_min; array[2] = lt->tm_sec;
}

#if 0                           /* dtime isn't used at present */
static long clk_tck = 0;

float dtime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  static time_t old_utime = 0, old_stime = 0;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  utime = buffer.tms_utime; stime = buffer.tms_stime;
  tarray[0] = ((float)(utime - old_utime)) / (float)clk_tck;
  tarray[1] = ((float)(stime - old_stime)) / (float)clk_tck;
  old_utime = utime; old_stime = stime;
  return (tarray[0]+tarray[1]);
}
#endif                          /* dtime */

float etime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  tarray[0] = (float) buffer.tms_utime / (float)clk_tck;
  tarray[1] = (float) buffer.tms_stime / (float)clk_tck;
  return (tarray[0]+tarray[1]);
}

#endif  /* AIX || HPUX */

#line 238 "library.nw"
#endif

