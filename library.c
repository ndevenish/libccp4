#line 87 "library.nw"
/* This was a literate program.  library.nw is the original source,
   from which library.c was generated by `notangle' and from which
   printable LaTeX can be produced by `noweave' if you have those
   tools.  The noweb system is available in
   anonymous@bellcore.com:pub/norman at the time of writing. */
#line 143 "library.nw"
#if F2C
/* #  define KNOWN_MACHINE */
#  define CALL_LIKE_SUN 1
#line 151 "library.nw"
#else
#if defined (_AIX)
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#line 158 "library.nw"
#if defined (alliant)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 165 "library.nw"
#if defined (ardent) || defined (titan)
#  ifndef stardent
#    define stardent
#  endif
#endif
#if defined (stardent)
#  define KNOWN_MACHINE
#  define CALL_LIKE_STARDENT 1
#endif
#line 180 "library.nw"
#if defined (__convex__) || defined (__convexc__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 189 "library.nw"
#if defined (ESV)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 196 "library.nw"
#if defined (__hpux) 
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#line 203 "library.nw"
#if defined (iris)
#  define KNOWN_MACHINE
#  define CALL_LIKE_IRIS 1
#endif
#line 212 "library.nw"
#ifdef __sgi   /* in ANSI mode */
#  ifndef sgi
#    define sgi
#  endif
#endif
#if defined (sgi)                     /* Silicon graphics with R3000's */
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 223 "library.nw"
#if defined (solbourne) 
#  ifndef sun
#   define sun               /* don't know whether it's defined or not */
#  endif
#endif
#line 230 "library.nw"
#if defined (sun)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#  ifndef __STDC__
#    define strerror(i) sys_errlist[i] /* k&r compiler doesn't have it */
#  endif
#endif
#line 242 "library.nw"
#if defined (ultrix) || defined(__OSF1__) || defined(__osf__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#line 248 "library.nw"
#if defined (VMS)
#  define KNOWN_MACHINE
#endif
#endif /* F2C */
#line 258 "library.nw"
#if ! defined (KNOWN_MACHINE)
  #error System type is not known -- see the Installation Guide
#else
#line 280 "library.nw"
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE
#endif
#line 284 "library.nw"
#include <stdio.h>

#if defined (VMS)
#  include <descrip.h>          /* non-POSIX */
#  define NOUNISTD
#else
#  include <sys/types.h>
#  include <sys/times.h>
#endif

#ifdef stardent                 /* who knows if this works anyhow... */
#  include <sys/types.h>
#  include <malloc.h>           /* non-POSIX */
#else
#  include <stddef.h>
#endif
#line 303 "library.nw"
#include <string.h>
#line 307 "library.nw"
#ifndef NOUNISTD
#  include <unistd.h>
#else
#  ifndef VMS
#    include <sys/file.h>       /* ESV, old Concentrix */ /* non-POSIX */
#  endif
#endif
#include <stdlib.h> 

#include <errno.h>
#include <ctype.h>

#if defined(_AIX) || defined (__hpux) /* would do no harm on others, though */
#  include <time.h>
#endif
#line 328 "library.nw"
#define MAXFLEN       500       /* the maximum length of a filename in CCP4 */
#define MAXFILES       10    /* maximum number of files open symultaneously */
#define DEFMODE         2    /* default mode access for random access files */
#line 334 "library.nw"
#define IRRELEVANT_OP   0
#define READ_OP         1
#define WRITE_OP        2
#line 343 "library.nw"
#ifndef SEEK_SET
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
#endif /* ! SEEK_SET */
#line 349 "library.nw"
#if defined (ardent) || defined (titan) || defined (stardent)
  struct Str_Desc {
    char *Str_pointer;
    int  Str_length;
    int id;
  };
#endif
#line 362 "library.nw"
#define BYTE  0
#define INT16 1   
#define INT32 6
#define FLOAT32 2
#define COMP32  3
#define COMP64  4
#line 1466 "library.nw"
/* class info codes for int */
#define DFNTI_MBO       1       /* Motorola byte order 2's compl */
#define DFNTI_IBO       4       /* Intel byte order 2's compl */

/* class info codes for float */
#define DFNTF_BEIEEE    1       /* big endian IEEE (canonical) */
#define DFNTF_VAX       2       /* Vax format */
#define DFNTF_CONVEXNATIVE 5    /* Convex native floats */
#define DFNTF_LEIEEE    4       /* little-endian IEEE format */
#line 1484 "library.nw"
#if defined (VAX) || defined (vax) /* gcc seems to use vax */
#  define NATIVEFT DFNTF_VAX
#  define NATIVEIT DFNTI_IBO
#endif
#line 1495 "library.nw"
#if defined(MIPSEL) || defined(alliant) || defined(i386) || defined(i860)
#  define NATIVEIT DFNTI_IBO
#  define NATIVEFT DFNTF_LEIEEE
#endif
#line 1504 "library.nw"
#ifdef __alpha
#  ifdef VMS
#    if __IEEE_FLOAT == 1
#      define NATIVEFT DFNTF_LEIEEE
#    else
#      define NATIVEFT DFNTF_VAX
#    endif
#  else                       /* assume OSF/1 */
#    define NATIVEFT DFNTF_LEIEEE
#  endif
#  define NATIVEIT DFNTI_IBO
#endif
#line 1521 "library.nw"
/* the VAX VMS compiler objected to splitting the following line */
#if defined(MIPSEB) || defined(__hpux) || defined(_AIX) || defined(m68k) || defined(mc68000) || defined(sparc)
#  define NATIVEIT DFNTI_MBO
#  define NATIVEFT DFNTF_BEIEEE
#endif
#line 1528 "library.nw"
#if defined(__convex__) || defined(__convexc__)
#  define NATIVEIT DFNTI_MBO
#  ifdef _IEEE_FLOAT_
#    define NATIVEFT DFNTF_BEIEEE
#  else
#    ifdef _CONVEX_FLOAT_
#      define NATIVEFT DFNTF_CONVEXNATIVE
#    else
       #error "Can't determine Convex floating point type. Use native compiler"
#    endif
#  endif
#endif
#ifndef NATIVEFT
  #error "Can't determine machine number format"
#endif
#line 1550 "library.nw"
#define DFNT_UINT       0       /* unsigned int */
#define DFNT_SINT       1       /* short int */
#define DFNT_INT        2       /* int */
#define DFNT_UCHAR      3       /* unsigned char */
#define DFNT_CHAR       4       /* char */
#define DFNT_FLOAT      5       /* float */
#define DFNT_DOUBLE     6       /* double */
#line 1559 "library.nw"
typedef unsigned short uint16;
typedef unsigned long uint32;
typedef float float32;
typedef unsigned char uint8;
#line 372 "library.nw"
static char rcsid[] = "$Id$";
static int initialised =  0;    /* flag to initialise data and file streams */
static char *file_attribute[] = { /* DISKIO file modes */
  "wb+",   /* 'UNKNOWN'   open as 'OLD'/'NEW' check existence */
  "wb+",   /* 'SCRATCH'   open as 'OLD' and delete on closing */
  "rb+",   /* 'OLD'       file MUST exist or program halts */
  "wb+",   /* 'NEW'       create (overwrite) new file */
  "rb"     /* 'READONLY'  self explanatory */
};                                                                      
#line 388 "library.nw"
static int item_sizes[] = {
  (int) sizeof (char),                                          /* 0: bytes */
#if defined (sgi)
  (int) sizeof (short),         /* silicon graphics bodge (This is fixed in
                                   IRIX4, at least) */
#else
  (int) sizeof (short int),                      /* 1: (integer) half words */
#endif
  (int) sizeof (float),                                   /* 2: reals/words */
  (int) sizeof (int),           /* 3: `short complex' (pairs of half words).
                                   NB int rather than 2*short since must fit
                                   into fortran integer */
  (int) 2*sizeof (float),                    /* 4: complex (pairs of words) */
  (int) sizeof (int),           /* 5: not used */
  (int) sizeof (int)            /* 6: integers */
};
#line 407 "library.nw"
static FILE *file_stream[MAXFILES];                 /* Pointer to disk file */
static char file_name[MAXFILES][MAXFLEN];      /* Pointer to disk file name */
static int  file_bytes_per_item[MAXFILES];/* Pointer to disk file item size */
static int  file_is_scratch[MAXFILES];    /* Indicates if file is 'SCRATCH' */
static int  file_last_op [MAXFILES];    /* see man fopen rd/wr combinations */
static int file_mode[MAXFILES];               /* diskio mode of each stream */
#line 1544 "library.nw"
static uint16 nativeIT = NATIVEIT; /* machine integer type */ 
static uint16 nativeFT = NATIVEFT; /* machine float type */
#line 1565 "library.nw"
union float_uint_uchar {
    float32 f;
    uint32 i;
    uint8 c[4]; };
static int
    Iconvert[MAXFILES],         /* integer convserion needed on read*/
    Fconvert[MAXFILES];         /* real convserion needed on read*/
#line 421 "library.nw"
static size_t flength (s, len)
char *s;
int len;
{
  while (s[--len] == ' ');
  return (++len);
}
#line 432 "library.nw"
static void fatal (message)
char *message;
{
  int one = 1;
#if CALL_LIKE_HPUX
  extern void ccperr();

  ccperr (&one, message, (int) strlen(message));
#endif
#if CALL_LIKE_STARDENT
  extern void CCPERR();
  struct Str_Desc str;

  str.Str_length = (int) strlen(message);
  str.Str_pointer = message;
  CCPERR (&one, &str);
#endif
#if defined (VMS)
  extern void CCPERR();
   struct dsc$descriptor_s str;

   str.dsc$a_pointer = message;
   str.dsc$w_length = (int) strlen(message);
   str.dsc$b_dtype = DSC$K_DTYPE_T;
   str.dsc$b_class = DSC$K_CLASS_S;
  CCPERR (&one, &str);
#endif
#if CALL_LIKE_SUN
  extern void ccperr_();

  ccperr_ (&one, message, (int) strlen(message));
#endif
#if CALL_LIKE_IRIS
  extern fortran ccperr_();

  (void) ccperr_ ((int) strlen(message), &one, message);
#endif
 }
#line 1656 "library.nw"
static void vaxF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[1] << 1) | (buffer[i].c[0] >> 7); /* extract exponent */
    if (!exp && !buffer[i].c[1])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[1] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[0];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    } else if (exp) {           /* denormalized number */
      int shft;

      out.c[0] = buffer[i].c[1] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[0] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[0] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
      out.c[3] = (uint8)(buffer[i].c[3] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[0] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    }
    buffer[i] = out;            /* copy back result */
  }
}
#line 1699 "library.nw"
static void ieeeF2vaxF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i<size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[0] = buffer[i].c[1];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[0] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[1] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[0] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[3] << shft);
      out.c[1] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[1] |= 0x01;
        out.c[0] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
#line 1751 "library.nw"
static void convexF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (!exp && !buffer[i].c[0])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[0] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    } else if (exp) {           /* denormalized number */
      int shft;
      
      out.c[0] = buffer[i].c[0] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[1] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[1] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
      out.c[3] = (uint8)(buffer[i].c[2] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[1] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    }
    buffer[i] = out;            /* copy back result */
  }
}
#line 1794 "library.nw"
static void ieeeF2convexF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i < size; i++) {
    exp = (uint8)(buffer[i].c[0] << 1) |
      (uint8)(buffer[i].c[1] >> 7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[3] = buffer[i].c[3];
      out.c[2] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[0] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[1] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[0] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[1] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[3] << shft);
      out.c[0] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[0] |= 0x01;
        out.c[1] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
#line 483 "library.nw"
#if ! defined (VMS)
#line 487 "library.nw"
#if CALL_LIKE_HPUX
  void ustenv (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_STARDENT
  void USTENV (str, result)
  struct Str_Desc *str;
#endif
#if CALL_LIKE_SUN
  void ustenv_ (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_IRIS
  fortran ustenv_ (Lstr, str, result)
  char *str;
  int  Lstr;
#endif
int *result;
{
  size_t Length;
  char name[MAXFLEN], value[MAXFLEN], *temp;

#if CALL_LIKE_STARDENT
  Length = flength (str->Str_pointer, str->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str->Str_pointer, Length);
#else
  Length = flength (str, Lstr);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str, Length);
#endif
  name[Length] = '\0'; 
#if defined (sgi) || defined (sun) || defined (__hpux) || \
    defined(_AIX) || defined(ultrix)
      /* putenv is the POSIX.1, draft 3 proposed mechanism */
      /* ESV seems to have it in the SysVile universe */
  temp = (char *) malloc (MAXFLEN);
  if (temp == NULL) fatal("USTENV: Memory allocation failed");
  (void) strcpy (temp, name);
  *result = putenv (temp);
  /* note the necessary lack of free() */
#else
  /* setenv is not POSIX */
  temp = (char *) strchr (name, '='); /* BSD might have to use `index' */
  if (temp != NULL) {
    *temp = '\0';
    temp++;
    (void) strcpy (value, temp);
  };
  *result = setenv (name, value, 1);
#endif
}
#line 485 "library.nw"
#endif
#line 548 "library.nw"
#if CALL_LIKE_HPUX
  void cunlink (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void CUNLINK (filename)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void CUNLINK (filename)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void cunlink_ (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran cunlink_ (Lfilename, filename)
  char *filename;
  int  Lfilename;
#endif
{
  size_t Length;
  char tempfile[MAXFLEN];

#ifdef VMS
  return;                       /* can't do it */
#else
#  if CALL_LIKE_STARDENT
    Length = flength (filename->Str_pointer, filename->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->Str_pointer, Length);
#  else
    Length = flength (filename, Lfilename);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename, Length);
#  endif
  tempfile[Length] = '\0';
  if (unlink (tempfile) != 0)
  fatal("CUNLINK: Can't unlink");
#endif /* VMS */
}
#line 605 "library.nw"
#if CALL_LIKE_HPUX
  void copen (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void COPEN (iunit, filename, istat)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void COPEN (iunit, filename, istat)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void copen_ (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran copen_ (iunit, Lfilename, filename, istat)
  char *filename;
  int  Lfilename;
#endif

int  *iunit, *istat;
{
  size_t Length;
  int i, jstat;

  jstat = *istat;
  if (! initialised) {
    /* note that array element 0 is unused -- using it produced
       complaints from mtzlib about a zero stream */
    for (i = 1; i < MAXFILES; i++) {
      file_stream[i]         = NULL;
      file_name[i][0]        = '\0';
      file_bytes_per_item[i] = item_sizes[DEFMODE];  /* default item size */
      file_is_scratch[i]     = 0;
      file_last_op[i]        = IRRELEVANT_OP;
      file_mode[i] = DEFMODE;
    }
    initialised = 1;
  }
  for (i = 1; i < MAXFILES; i++) /* Find next available stream */
    if (file_stream[i] == NULL) break;
  if (i == MAXFILES) {
    *iunit = -1;                /* return no more units flag */
    return;
  } else {
    *iunit = i;}                 /* will return the stream number */
#if CALL_LIKE_STARDENT
  Length = flength (filename->Str_pointer, filename->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->Str_pointer, Length);
#else
#  if defined (VMS)
  Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->dsc$a_pointer, Length);
#  else
  Length = flength (filename, Lfilename);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename, Length);
#  endif
#endif
  file_name[i][Length] = '\0';
  file_last_op[i] = IRRELEVANT_OP;
  file_bytes_per_item[i] = item_sizes[DEFMODE]; /* default item size */
  file_mode[i] = DEFMODE;
  file_is_scratch[i] = (jstat == 2);
#line 696 "library.nw"
#ifdef VMS
  if (file_is_scratch[i])
    file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1],
                            "mbc=16", /* bigger blocksize */
                            "fop=tmd"); /* temporary, delete on close */
  else
    file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1],
                            "mbc=16", /* bigger blocksize */
                            "ctx=stm", "mrs=0", "rat=cr", "rfm=stmlf");
#else
  file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1]);
  if (file_is_scratch[i] && unlink (file_name[i])!=0)
    fatal ("(Q)QOPEN: error unlinking scratch file");
#endif
  if (file_stream[i] == NULL) {
    *iunit = -2;                /* return open failure flag */
    return; }
  Iconvert[i] = Fconvert[i] = 0;
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 715 "library.nw"
  if (fseek (file_stream[*iunit], 0L, SEEK_SET) != 0)
    fatal("(Q)QOPEN: fseek failed");
  *iunit = i;
}
#line 755 "library.nw"
#if CALL_LIKE_HPUX
  void qrarch (iunit, ipos, ireslt)
#endif
#if CALL_LIKE_STARDENT
  void QRARCH (iunit, ipos, ireslt)
#endif
#if defined (VMS)
  void QRARCH (iunit, ipos, ireslt)
#endif
#if CALL_LIKE_SUN
  void qrarch_ (iunit, ipos, ireslt)
#endif
#if CALL_LIKE_IRIS
  fortran qrarch_ (iunit, ipos, ireslt)
#endif
  int *ipos, *ireslt, *iunit;
{
  uint16 fileFT, fileIT;        /* float and integer machine types of file */
  unsigned char mtstring[4];    /* machine stamp */
  char *native = getenv ("NATIVEMTZ");
  char *foreign = getenv ("CONVERT_FROM");

  if (native != NULL) { *ireslt = 0; return; }
  if (foreign != NULL) {
    if (strcmp (foreign, "BEIEEE") == 0) {
      mtstring[0] = DFNTF_BEIEEE | (DFNTF_BEIEEE << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "LEIEEE") == 0) {
      mtstring[0] = DFNTF_LEIEEE | (DFNTF_LEIEEE << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "VAX") == 0) {
      mtstring[0] = DFNTF_VAX | (DFNTF_VAX << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "CONVEXNATIVE") == 0) {
      mtstring[0] = DFNTF_CONVEXNATIVE | (DFNTF_CONVEXNATIVE << 4);
      mtstring[1] = 1 | (DFNTI_MBO << 4); }  
  } else {
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 793 "library.nw"
    if ((fseek (file_stream[*iunit], (size_t) ((*ipos)*item_sizes[2]),
                SEEK_SET) != 0))
      fatal ("QRARCH: seek failed");
    file_last_op[*iunit] = READ_OP;
    if (fread (mtstring, (size_t) sizeof(char), (size_t) 4,
               file_stream[*iunit]) != 4)
      fatal ("QRARCH: can't read machine stamp");
  }
  fileIT = (mtstring[1]>>4) & 0x0f;
  fileFT = (mtstring[0]>>4) & 0x0f;
  /* Record the need for conversion and what the file type is: */
  if (fileFT != 0 && fileFT != nativeFT)
    Fconvert[*iunit] = fileFT;  /* else assume native */
  if (fileIT != 0 && fileIT != nativeIT)
    Iconvert[*iunit] = fileIT;  /* else assume native */
  *ireslt = fileFT + (16*fileIT);
}
#line 824 "library.nw"
#if CALL_LIKE_HPUX
  void qwarch (iunit, ipos)
#endif
#if CALL_LIKE_STARDENT
  void QWARCH (iunit, ipos)
#endif
#if defined (VMS)
  void QWARCH (iunit, ipos)
#endif
#if CALL_LIKE_SUN
  void qwarch_ (iunit, ipos)
#endif
#if CALL_LIKE_IRIS
  fortran qwarch_ (iunit, ipos)
#endif
  int *ipos, *iunit;
{
  unsigned char mtstring[4];    /* machine stamp */
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 843 "library.nw"
  if (fseek (file_stream[*iunit], (size_t) ((*ipos)*item_sizes[2]),
             SEEK_SET) != 0)
    fatal ("QWARCH: seek failed");
  /* nibbles packed by masking and ORing: */
  mtstring[0] = nativeFT | (nativeFT << 4);
  mtstring[1] = 1 | (nativeIT << 4);
  mtstring[2] = mtstring[3] = 0;
  file_last_op[*iunit] = WRITE_OP;
  if (fwrite (mtstring, (size_t) sizeof(char), (size_t) 4,
             file_stream[*iunit]) != 4)
    fatal ("QWARCH: can't write machine stamp");
}
#line 859 "library.nw"
#if CALL_LIKE_HPUX
  void qclose (iunit)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QCLOSE (iunit)
#endif
#if CALL_LIKE_SUN
  void qclose_ (iunit)
#endif
#if CALL_LIKE_IRIS
  fortran qclose_ (iunit)
#endif

int *iunit;
{
  int l;
  if (! initialised) 
    fatal ("QCLOSE: qopen/qqopen not yet called");
  if (file_stream[*iunit] != NULL) {
    if (fclose (file_stream[*iunit]) == EOF) 
      fatal ("QCLOSE: failed"); /* fixme: add file name to message */
    file_stream[*iunit] = NULL;
  }
  file_name[*iunit][0] = '\0';
}
#line 891 "library.nw"
#if CALL_LIKE_HPUX
  void qmode (iunit, mode, size)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QMODE (iunit, mode, size)
#endif
#if CALL_LIKE_SUN
  void qmode_ (iunit, mode, size)
#endif
#if CALL_LIKE_IRIS
  fortran qmode_ (iunit, mode, size)
#endif

int *iunit, *mode, *size;
{
  if (! initialised) 
    fatal ("QMODE: qopen/qqopen not yet called");

  if (*mode >= 0 && *mode <= 6 && *mode != 5)
    file_bytes_per_item[*iunit] = item_sizes[*mode];
  else
    fatal ("QMODE: bad mode");
  *size = file_bytes_per_item[*iunit];       /* return number of bytes/item */
  file_mode[*iunit] = *mode;
}
#line 926 "library.nw"
#if CALL_LIKE_HPUX
  void qread (iunit, buffer, nitems, result)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QREAD (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_SUN
  void qread_ (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_IRIS
  fortran qread_ (iunit, buffer, nitems, result)
#endif

uint8 * buffer;
int *iunit, *nitems, *result;
{
  int i, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP) {
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 948 "library.nw"
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      *result = -1;
      return; } }
  file_last_op[*iunit] = READ_OP;
  i = fread (buffer, (size_t) file_bytes_per_item[*iunit], 
                (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) {
    if (feof (file_stream[*iunit])) *result = -1;
    else *result = i;
    return;
  }
  *result = 0;
  n = *nitems;
  
#line 965 "library.nw"
  switch (file_mode[*iunit]) {
  case BYTE:
    break;
  case INT16:
    if (Iconvert[*iunit])
      
#line 1578 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO)) {
  char j;
  for (i=0; i < n*2; i+=2) {
    j = buffer[i];
    buffer[i] = buffer[i+1];
    buffer[i+1] = j; } }
else
  fatal("QREAD: bad file integer type in conversion");
}
#line 971 "library.nw"
    break;
  case INT32:
    if (Iconvert[*iunit])
      
#line 1590 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO))
  
#line 1639 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1594 "library.nw"
else
  fatal("QREAD: bad file integer type in conversion");
}
#line 975 "library.nw"
    break;
  case FLOAT32:
    if (Fconvert[*iunit])
      
#line 1601 "library.nw"
{
switch (Fconvert[*iunit]) {     /* get to BE IEEE */
   case DFNTF_VAX :
     vaxF2ieeeF(buffer, n);
     break;   
   case DFNTF_CONVEXNATIVE :
     convexF2ieeeF(buffer, n);
     break;
   case DFNTF_BEIEEE :
     break;
   case DFNTF_LEIEEE :
     
#line 1639 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1613 "library.nw"
     break;
   default :
     fatal("QREAD: bad file real type in conversion");
   }
#line 1622 "library.nw"
switch (nativeFT) {
  case DFNTF_BEIEEE :
    break;                      /* done enough */
  case DFNTF_LEIEEE :
    
#line 1639 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1627 "library.nw"
    break;
  case DFNTF_CONVEXNATIVE :
    ieeeF2convexF(buffer, n);
    break;
  case DFNTF_VAX :
    ieeeF2vaxF(buffer, n);
    break;
  default :
    fatal("QREAD: bad native real type in conversion");
  }
}
#line 979 "library.nw"
    break;
  case COMP32:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of ints */
      
#line 1578 "library.nw"
{
if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO)) {
  char j;
  for (i=0; i < n*2; i+=2) {
    j = buffer[i];
    buffer[i] = buffer[i+1];
    buffer[i+1] = j; } }
else
  fatal("QREAD: bad file integer type in conversion");
}
#line 984 "library.nw"
    }
    break;
  case COMP64:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of reals */
      
#line 1601 "library.nw"
{
switch (Fconvert[*iunit]) {     /* get to BE IEEE */
   case DFNTF_VAX :
     vaxF2ieeeF(buffer, n);
     break;   
   case DFNTF_CONVEXNATIVE :
     convexF2ieeeF(buffer, n);
     break;
   case DFNTF_BEIEEE :
     break;
   case DFNTF_LEIEEE :
     
#line 1639 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1613 "library.nw"
     break;
   default :
     fatal("QREAD: bad file real type in conversion");
   }
#line 1622 "library.nw"
switch (nativeFT) {
  case DFNTF_BEIEEE :
    break;                      /* done enough */
  case DFNTF_LEIEEE :
    
#line 1639 "library.nw"
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
#line 1627 "library.nw"
    break;
  case DFNTF_CONVEXNATIVE :
    ieeeF2convexF(buffer, n);
    break;
  case DFNTF_VAX :
    ieeeF2vaxF(buffer, n);
    break;
  default :
    fatal("QREAD: bad native real type in conversion");
  }
}
#line 990 "library.nw"
    }
    break;
  default:
    fatal ("QREAD: Bad mode");
  }
#line 962 "library.nw"
}
#line 1004 "library.nw"
#if CALL_LIKE_HPUX
  void qreadc (iunit, buffer, result, Lbuffer)
  int Lbuffer;
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QREADC (iunit, buffer, result)
  struct dsc$descriptor_s *buffer;
#endif
#if CALL_LIKE_SUN
  void qreadc_ (iunit, buffer, result, Lbuffer)
  int Lbuffer;
#endif
#if CALL_LIKE_IRIS
  fortran qreadc_ (Lbuffer, iunit, buffer, result)
  int Lbuffer;
#endif

char * buffer;
int *iunit, *result;
{
  int i, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP) {
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1030 "library.nw"
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      *result = -1;
      return; } }
  file_last_op[*iunit] = READ_OP;
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  n = buffer->Str_length;
#else
  n = Lbuffer;
#endif
  i = fread (buffer, (size_t) item_sizes[BYTE], 
                (size_t) n, file_stream[*iunit]);
  if (i != n) {
    if (feof (file_stream[*iunit])) *result = -1;
    else *result = i;
    return;
  }
  *result = 0;
}
#line 1053 "library.nw"
#if CALL_LIKE_HPUX
  void qwrite (iunit, buffer, nitems)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QWRITE (iunit, buffer, nitems)
#endif
#if CALL_LIKE_SUN
  void qwrite_ (iunit, buffer, nitems)
#endif
#if CALL_LIKE_IRIS
  fortran qwrite_ (iunit, buffer, nitems)
#endif
uint8 * buffer;
int *iunit, *nitems;
{
  int i;

  if (! initialised) 
    fatal ("QWRITE: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP) {
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1074 "library.nw"
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITE: i/o error"); }
  file_last_op[*iunit] = WRITE_OP;
  i = (int) fwrite (buffer, (size_t) file_bytes_per_item[*iunit],
                    (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) fatal ("QWRITE: i/o error");
}
#line 1086 "library.nw"
#if CALL_LIKE_HPUX
  void qwritec (iunit, buffer, Lbuffer)
  int Lbuffer;
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QWRITEC (iunit, buffer)
  struct dsc$descriptor_s *buffer;
#endif
#if CALL_LIKE_SUN
  void qwritec_ (iunit, buffer, Lbuffer)
  int Lbuffer;
#endif
#if CALL_LIKE_IRIS
  fortran qwritec_ (Lbuffer, iunit, nitems)
  int Lbuffer;
#endif
char * buffer;
int *iunit;
{
  int i, n;

  if (! initialised) 
    fatal ("QWRITE: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP) {
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1111 "library.nw"
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITE: i/o error"); }
  file_last_op[*iunit] = WRITE_OP;
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  n = buffer->Str_length;
#else
  n = Lbuffer;
#endif
  i = (int) fwrite (buffer, (size_t) item_sizes[BYTE],
                    (size_t) n, file_stream[*iunit]);
  if (i != n) fatal ("QWRITE: i/o error");
}
#line 1128 "library.nw"
#if CALL_LIKE_HPUX
  void qseek (iunit, irec, iel, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QSEEK (iunit, irec, iel, lrecl)
#endif
#if CALL_LIKE_SUN
  void qseek_ (iunit, irec, iel, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qseek_ (iunit, irec, iel, lrecl)
#endif

int *iunit, *irec, *iel, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSEEK: qopen/qqopen not yet called");
  position = (long) ((*lrecl)*(*irec - 1) + (*iel - 1));
  position *= (long) file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1151 "library.nw"
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSEEK failed");     /* fixme: add file info */
}
#line 1158 "library.nw"
#if CALL_LIKE_HPUX
  void qback (iunit, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QBACK (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qback_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qback_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QBACK: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) - (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1180 "library.nw"
  if (fseek (file_stream[*iunit], position, SEEK_SET) != 0)
    fatal ("QBACK failed");     /* fixme: add file info */
}
#line 1194 "library.nw"
#if CALL_LIKE_HPUX
  void qskip (iunit, lrecl)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QSKIP (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qskip_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qskip_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSKIP: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) +
    (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1217 "library.nw"
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSKIP failed");     /* fixme: add file info */
}
#line 1226 "library.nw"
#if CALL_LIKE_HPUX
  void cqinq (istrm, filnam, length, len_filnam)
  char *filnam; 
  int len_filnam;
#endif
#if CALL_LIKE_STARDENT
  void CQINQ (istrm, filnam, length)
  struct Str_Desc *filnam;
#endif
#if defined (VMS)
  void CQINQ (istrm, filnam, length)
  struct dsc$descriptor_s *filnam;
#endif
#if CALL_LIKE_SUN
  void cqinq_ (istrm, filnam, length, len_filnam)
  char *filnam;
  int len_filnam;
#endif
#if CALL_LIKE_IRIS
  fortran cqinq_ (istrm, len_filnam, filnam, length)
  char *filnam;
  int len_filnam;
#endif

int *istrm, *length;
{
  char real_name[MAXFLEN];
  int *iunit, Length, i;
  long position;

  if (! initialised) 
    fatal ("QQINQ:,qopen/qqopen not yet called");
  *length = -1;                                    /* default return value */
  iunit = istrm;
  if (file_stream[*iunit] == NULL) { 
    /* no unit open -- try file name */
#if CALL_LIKE_STARDENT
    Length = flength (filnam->Str_pointer, filnam->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (real_name, filnam->Str_pointer, Length);
#else
#  if defined (VMS)
     Length = flength (filnam->dsc$a_pointer, filnam->dsc$w_length);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam->dsc$a_pointer, Length);
#  else
     Length = flength (filnam, len_filnam);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam, Length);
#  endif
#endif
    real_name[Length] = '\0';
    for (i = 1; i < MAXFILES; i++)
      if (! strcmp (real_name, file_name[i])) break;
    *iunit = i % MAXFILES;
  }
  if (file_stream[*iunit] != NULL) {
    file_last_op[*iunit] = IRRELEVANT_OP;
    (void) fflush (file_stream[*iunit]); /* flush the output stream */
#if 0
    /* checking the return value reportedly causes problems in ultrix
       under unknown circumstances... */
    if (fflush (file_stream[*iunit]) != 0) fatal ("QQINQ: flush failed");
#endif
    position = ftell (file_stream[*iunit]);   /* remember current position */
#line 1188 "library.nw"
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
#line 1292 "library.nw"
    (void) fseek (file_stream[*iunit],0L,SEEK_END); /* seek EOF */
    *length = (int) ftell (file_stream[*iunit]); /* get file size */
    if (fseek (file_stream[*iunit],position,SEEK_SET) != 0) /* seek position */
      fatal ("QQINQ: seek failed"); /* fixme: add file info */
  }
}
#line 1302 "library.nw"
#if CALL_LIKE_HPUX
  void qlocate (iunit, locate)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QLOCATE (iunit, locate)
#endif
#if CALL_LIKE_SUN
  void qlocate_ (iunit, locate)
#endif
#if CALL_LIKE_IRIS
  fortran qlocate_ (iunit, locate)
#endif

int *iunit, *locate;
{
  if (! initialised) 
    fatal ("QLOCATE: qopen/qqopen not yet called");
  *locate = -1;
  if (file_stream[*iunit] != NULL)
    *locate = (int) ftell (file_stream[*iunit]) / file_bytes_per_item[*iunit];
}
#line 1329 "library.nw"
#ifdef _AIX
void idate (d, m, y)
     int *y, *m, *d;
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     *y = lt->tm_year + 1000; *m = lt->tm_mon; *d = lt->tm_mday;
}
#endif
#line 1341 "library.nw"
#if defined (__hpux) || defined (_AIX)
void gerror (str, Lstr)
char *str;
int  Lstr;
{
  int i;

  if (errno == 0) {             /* Avoid `Error 0' or some such message */
    for (i=1; Lstr; i++)
      str[i] = ' ';
  } else {
    (void) strncpy (str, strerror (errno), Lstr);
    for (i = strlen (str); i < Lstr; i++) str[i] = ' ';  /* pad with spaces */
  }
} /* End of gerror (str, Lstr) */

int ierrno () {
  return errno;
}

void itime (array)
     int array[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     array[0] = lt->tm_hour; array[1] = lt->tm_min; array[2] = lt->tm_sec;
}

static long clk_tck = 0;

#if 0                           /* dtime isn't used at present */
float dtime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  static time_t old_utime = 0, old_stime = 0;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  utime = buffer.tms_utime; stime = buffer.tms_stime;
  tarray[0] = ((float)(utime - old_utime)) / (float)clk_tck;
  tarray[1] = ((float)(stime - old_stime)) / (float)clk_tck;
  old_utime = utime; old_stime = stime;
  return (tarray[0]+tarray[1]);
}
#endif                          /* dtime */

float etime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  tarray[0] = (float) buffer.tms_utime / (float)clk_tck;
  tarray[1] = (float) buffer.tms_stime / (float)clk_tck;
  return (tarray[0]+tarray[1]);
}

#endif  /* AIX || HPUX */
#line 1893 "library.nw"
#if CALL_LIKE_HPUX
  float qnan ()
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  float QNAN ()
#endif
#if CALL_LIKE_SUN || CALL_LIKE_IRIS
  float qnan_ ()
#endif
#line 1908 "library.nw"
#if NATIVEFT == DFNTF_BEIEEE
#  define NAN 0xfffa5a5a
#endif
#if NATIVEFT == DFNTF_LEIEEE
#  define NAN 0x5a5afaff
#endif
#line 1917 "library.nw"
#if NATIVEFT == DFNTF_CONVEXNATIVE
#  define NAN 0x80000000
#endif
#if NATIVEFT == DFNTF_VAX
#  define NAN 0x00008000
#endif
#ifndef NAN
  #error "NAN isn't defined (needs NATIVEFT)"
#endif
{
  union float_uint_uchar NaNvalue; /* can't initialise union in K&R */

  NaNvalue.i = NAN;
  return NaNvalue.f;
}
#line 1941 "library.nw"
#if CALL_LIKE_HPUX
  int cisnan (real)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  int CISNAN (real)
#endif
#if CALL_LIKE_SUN
  int cisnan_ (real)
#endif
#if CALL_LIKE_IRIS
  int cisnan_ (real)
#endif
  union float_uint_uchar real;
{
    
#line 1961 "library.nw"
switch (nativeFT) {
 case DFNTF_BEIEEE :
   return (((real.i & 0x7f800000)
            == 0x7f800000)     /* exponent all 1s */
           && ((real.i & 0x007fffff)
               == 0));          /* non-zero fraction */
 case DFNTF_LEIEEE :
   return (((real.i & 0x0000807f)
            == 0x0000807f)      /* exponent all 1s */
           && ((real.i & 0xffff7f00)
               == 0));          /* non-zero fraction */
#line 1976 "library.nw"
  case DFNTF_CONVEXNATIVE :
    return ((real.i & 0xff800000) == 0x80000000);      
  case DFNTF_VAX :
    return ((real.i & 0x0000ff80) == 0x00008000);
  default :
    fatal("CISNAN: bad nativeFT");  }
#line 1956 "library.nw"
}
#line 262 "library.nw"
#endif

