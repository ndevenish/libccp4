/* This was a literate program.  library.nw is the original source,
   from which library.c was generated by `notangle' and from which
   printable LaTeX can be produced by `noweave' if you have those
   tools.  The noweb system is available in
   anonymous@bellcore.com:pub/norman at the time of writing. */
#if defined (_AIX)
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#if defined (alliant)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#if defined (ardent) || defined (titan)
#  ifndef stardent
#    define stardent
#  endif
#endif
#if defined (stardent)
#  define KNOWN_MACHINE
#  define CALL_LIKE_STARDENT 1
#endif
#if defined (__convex__) || defined (__convexc__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#if defined (ESV)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#if defined (__hpux) 
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
#ifdef __sgi   /* in ANSI mode */
#  ifndef sgi
#    define sgi
#  endif
#endif
#if defined (sgi)                     /* Silicon graphics with R3000's */
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#if defined (solbourne) 
#  ifndef sun
#   define sun               /* don't know whether it's defined or not */
#  endif
#endif
#if defined (sun) || defined (__sun)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#  if !defined(__STDC__) || defined(__GNUC__)
     extern char *sys_errlist [];
#    define strerror(i) sys_errlist[i] /* k&r compiler doesn't have it */
#  endif
#endif
#if defined (ultrix) || defined(__OSF1__) || defined(__osf__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
#ifndef VMS
#  if defined (vms) || defined (__vms) || defined (__VMS)
#    define VMS
#  endif
#endif
#if defined (VMS)
#  define KNOWN_MACHINE
#endif
#if defined(F2C) || defined(G77)
#  undef CALL_LIKE_SUN
#  define CALL_LIKE_SUN 1
#endif
#if ! defined (KNOWN_MACHINE)
  #error System type is not known -- see the Installation Guide
#else
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE
#endif
#include <stdio.h>

#if defined (VMS)
#  include <descrip.h>          /* non-POSIX */
#  define NOUNISTD
#else
#  include <sys/types.h>
#  include <sys/times.h>
#endif

#ifdef stardent                 /* who knows if this works anyhow... */
#  include <sys/types.h>
#  include <malloc.h>           /* non-POSIX */
#else
#  include <stddef.h>
#endif
#include <string.h>
#ifndef NOUNISTD
#  include <unistd.h>
#else
#  ifndef VMS
#    include <sys/file.h>       /* ESV, old Concentrix */ /* non-POSIX */
#  endif
#endif
#include <stdlib.h> 

#include <errno.h>
#include <ctype.h>

#if defined(_AIX) || defined (__hpux) || defined(F2C) ||\
    defined(G77) /* would do no harm on others, though */
#  include <time.h>
#endif
#define MAXFLEN       500       /* the maximum length of a filename in CCP4 */
#define MAXFILES       10    /* maximum number of files open symultaneously */
#define DEFMODE         2    /* default mode access for random access files */
#define IRRELEVANT_OP   0
#define READ_OP         1
#define WRITE_OP        2
#ifndef SEEK_SET
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
#endif /* ! SEEK_SET */
#if defined (ardent) || defined (titan) || defined (stardent)
  struct Str_Desc {
    char *Str_pointer;
    int  Str_length;
    int id;
  };
#endif
#define BYTE  0
#define INT16 1   
#define INT32 6
#define FLOAT32 2
#define COMP32  3
#define COMP64  4
/* class info codes for int */
#define DFNTI_MBO       1       /* Motorola byte order 2's compl */
#define DFNTI_IBO       4       /* Intel byte order 2's compl */

/* class info codes for float */
#define DFNTF_BEIEEE    1       /* big endian IEEE (canonical) */
#define DFNTF_VAX       2       /* Vax format */
#define DFNTF_CONVEXNATIVE 5    /* Convex native floats */
#define DFNTF_LEIEEE    4       /* little-endian IEEE format */
#if defined (VAX) || defined (vax) /* gcc seems to use vax */
#  define NATIVEFT DFNTF_VAX
#  define NATIVEIT DFNTI_IBO
#endif
#if defined(MIPSEL) || defined(alliant) || defined(i386) || defined(i860)
#  define NATIVEIT DFNTI_IBO
#  define NATIVEFT DFNTF_LEIEEE
#endif
#ifdef __alpha
#  ifdef VMS
#    if __IEEE_FLOAT == 1
#      define NATIVEFT DFNTF_LEIEEE
#    else
#      define NATIVEFT DFNTF_VAX
#    endif
#  else                       /* assume OSF/1 */
#    define NATIVEFT DFNTF_LEIEEE
#  endif
#  define NATIVEIT DFNTI_IBO
#endif
/* the VAX VMS compiler objected to splitting the following line */
#if defined(MIPSEB) || defined(__hpux) || defined(_AIX) || defined(m68k) || defined(mc68000) || defined(sparc)
#  define NATIVEIT DFNTI_MBO
#  define NATIVEFT DFNTF_BEIEEE
#endif
#if defined(__convex__) || defined(__convexc__)
#  define NATIVEIT DFNTI_MBO
#  ifdef _IEEE_FLOAT_
#    define NATIVEFT DFNTF_BEIEEE
#  else
#    ifdef _CONVEX_FLOAT_
#      define NATIVEFT DFNTF_CONVEXNATIVE
#    else
       #error "Can't determine Convex floating point type. Use native compiler"
#    endif
#  endif
#endif
#ifndef NATIVEFT
  #error "Can't determine machine number format"
#endif
#define DFNT_UINT       0       /* unsigned int */
#define DFNT_SINT       1       /* short int */
#define DFNT_INT        2       /* int */
#define DFNT_UCHAR      3       /* unsigned char */
#define DFNT_CHAR       4       /* char */
#define DFNT_FLOAT      5       /* float */
#define DFNT_DOUBLE     6       /* double */
typedef unsigned short uint16;
#ifdef SIXTEENBIT
typedef unsigned long uint32;
#else
typedef unsigned int uint32;
#endif
typedef float float32;
typedef unsigned char uint8;
/* typedef signed char sint8; */ /* not K&R ? */
static char rcsid[] = "$Id$";
static int initialised =  0;    /* flag to initialise data and file streams */
#if defined(__DECC) && defined(VMS)
static char *file_attribute[] = { /* DISKIO file modes */
  "wb+",   /* 'UNKNOWN'   open as 'OLD'/'NEW' check existence */
  "wb+",   /* 'SCRATCH'   open as 'OLD' and delete on closing */
  "rb+",   /* 'OLD'       file MUST exist or program halts */
  "wb+",   /* 'NEW'       create (overwrite) new file */
  "rb"     /* 'READONLY'  self explanatory */
#else
static char *file_attribute[] = {
  "w+",   /* 'UNKNOWN'   open as 'OLD'/'NEW' check existence */
  "w+",   /* 'SCRATCH'   open as 'OLD' and delete on closing */
  "r+",   /* 'OLD'       file MUST exist or program halts */
  "w+",   /* 'NEW'       create (overwrite) new file */
  "r"     /* 'READONLY'  self explanatory */
#endif
};                                                                      
static int item_sizes[] = {
  (int) sizeof (char),                                          /* 0: bytes */
#if defined (sgi)
  (int) sizeof (short),         /* silicon graphics bodge (This is fixed in
                                   IRIX4, at least) */
#else
  (int) sizeof (short int),                      /* 1: (integer) half words */
#endif
  (int) sizeof (float),                                   /* 2: reals/words */
  (int) sizeof (int),           /* 3: `short complex' (pairs of half words).
                                   NB int rather than 2*short since must fit
                                   into fortran integer */
  (int) 2*sizeof (float),                    /* 4: complex (pairs of words) */
  (int) sizeof (int),           /* 5: not used */
  (int) sizeof (int)            /* 6: integers */
};
static FILE *file_stream[MAXFILES];                 /* Pointer to disk file */
static char file_name[MAXFILES][MAXFLEN];      /* Pointer to disk file name */
static int  file_bytes_per_item[MAXFILES];/* Pointer to disk file item size */
static int  file_is_scratch[MAXFILES];    /* Indicates if file is 'SCRATCH' */
static int  file_last_op [MAXFILES];    /* see man fopen rd/wr combinations */
static int file_mode[MAXFILES];               /* diskio mode of each stream */
static uint16 nativeIT = NATIVEIT; /* machine integer type */ 
static uint16 nativeFT = NATIVEFT; /* machine float type */
union float_uint_uchar {
    float32 f;
    uint32 i;
    uint8 c[4];
/*    sint8 s[4]; */
  };
static int
    Iconvert[MAXFILES],         /* integer convserion needed on read*/
    Fconvert[MAXFILES];         /* real convserion needed on read*/
static size_t flength (s, len)
char *s;
int len;
{
  while (s[--len] == ' ');
  return (++len);
}
static void fatal (message)
char *message;
{
  int mone = -1, zero = 0;
#if CALL_LIKE_HPUX
  extern void ccperr();

  ccperr (&mone, message, (int) strlen(message));
#endif
#if CALL_LIKE_STARDENT
  extern void CCPERR();
  struct Str_Desc str;

  str.Str_length = (int) strlen(message);
  str.Str_pointer = message;
  CCPERR (&mone, &str);
#endif
#if defined (VMS)
  extern void CCPERR();
  extern void QPRINT();
  struct dsc$descriptor_s str;

  str.dsc$a_pointer = strerror(errno, vaxc$errno);
  str.dsc$w_length = (int) strlen(str.dsc$a_pointer);
  str.dsc$b_dtype = DSC$K_DTYPE_T;
  str.dsc$b_class = DSC$K_CLASS_S;
  QPRINT (&zero, &str);
  str.dsc$a_pointer = message;
  str.dsc$w_length = (int) strlen(message);
  str.dsc$b_dtype = DSC$K_DTYPE_T;
  str.dsc$b_class = DSC$K_CLASS_S;
  CCPERR (&mone, &str);
#endif
#if CALL_LIKE_SUN
  extern void ccperr_();

  ccperr_ (&mone, message, (int) strlen(message));
#endif
 }
static void cqprint (message)
char *message;
{
  int zero = 0;
#if CALL_LIKE_HPUX
  extern void qprint();

  qprint (&zero, message, (int) strlen(message));
#endif
#if CALL_LIKE_STARDENT
  extern void QPRINT();
  struct Str_Desc str;

  str.Str_length = (int) strlen(message);
  str.Str_pointer = message;
  QPRINT (&zero, &str);
#endif
#if defined (VMS)
  extern void QPRINT();
  struct dsc$descriptor_s str;

  str.dsc$a_pointer = message;
  str.dsc$w_length = (int) strlen(message);
  str.dsc$b_dtype = DSC$K_DTYPE_T;
  str.dsc$b_class = DSC$K_CLASS_S;
  QPRINT (&zero, &str);
#endif
#if CALL_LIKE_SUN
  extern void qprint_();

  qprint_ (&zero, message, (int) strlen(message));
#endif
 }
static void vaxF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[1] << 1) | (buffer[i].c[0] >> 7); /* extract exponent */
    if (!exp && !buffer[i].c[1])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[1] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[0];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    } else if (exp) {           /* denormalized number */
      int shft;

      out.c[0] = buffer[i].c[1] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[0] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[0] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
      out.c[3] = (uint8)(buffer[i].c[3] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[0] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    }
    buffer[i] = out;            /* copy back result */
  }
}
static void ieeeF2vaxF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i<size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[0] = buffer[i].c[1];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[0] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[1] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[0] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[3] << shft);
      out.c[1] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[1] |= 0x01;
        out.c[0] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
static void convexF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[0]<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (!exp && !buffer[i].c[0])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[0] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    } else if (exp) {           /* denormalized number */
      int shft;
      
      out.c[0] = buffer[i].c[0] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[1] & 0x7f) >> shft) |
        (uint8)(0x10 << exp);
      out.c[2] = (uint8)(buffer[i].c[1] << (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
      out.c[3] = (uint8)(buffer[i].c[2] << (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[1] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    }
    buffer[i] = out;            /* copy back result */
  }
}
static void ieeeF2convexF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i < size; i++) {
    exp = (uint8)(buffer[i].c[0] << 1) |
      (uint8)(buffer[i].c[1] >> 7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[3] = buffer[i].c[3];
      out.c[2] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[0] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[1] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[0] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[1] = (uint8)(buffer[i].c[1] << shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[2] << shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[3] << shft);
      out.c[0] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[0] |= 0x01;
        out.c[1] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
#if ! defined (VMS)
#if CALL_LIKE_HPUX
  void ustenv (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_STARDENT
  void USTENV (str, result)
  struct Str_Desc *str;
#endif
#if CALL_LIKE_SUN
  void ustenv_ (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
int *result;
{
  size_t Length;
  char name[MAXFLEN], value[MAXFLEN], *temp;

#if CALL_LIKE_STARDENT
  Length = flength (str->Str_pointer, str->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str->Str_pointer, Length);
#else
  Length = flength (str, Lstr);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str, Length);
#endif
  name[Length] = '\0'; 
#if defined (sgi) || defined (sun) || defined (__hpux) || \
    defined(_AIX) || defined(ultrix) || defined (__OSF1__) || \
    defined (__osf__) || defined (__FreeBSD__) || defined (linux) || \
    defined (titan)
      /* putenv is the POSIX.1, draft 3 proposed mechanism */
      /* ESV seems to have it in the SysVile universe */
  temp = (char *) malloc (MAXFLEN);
  if (temp == NULL) fatal("USTENV: Memory allocation failed");
  (void) strcpy (temp, name);
  *result = putenv (temp);
  /* note the necessary lack of free() */
#else
  /* setenv is not POSIX */
  temp = (char *) strchr (name, '='); /* BSD might have to use `index' */
  if (temp != NULL) {
    *temp = '\0';
    temp++;
    (void) strcpy (value, temp);
  };
  *result = setenv (name, value, 1);
#endif
}
#endif
#if CALL_LIKE_HPUX
  void cunlink (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void CUNLINK (filename)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void CUNLINK (filename)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void cunlink_ (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
{
  size_t Length;
  char tempfile[MAXFLEN];

#ifdef VMS
  return;                       /* can't do it */
#else
#  if CALL_LIKE_STARDENT
    Length = flength (filename->Str_pointer, filename->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->Str_pointer, Length);
#  else
    Length = flength (filename, Lfilename);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename, Length);
#  endif
  tempfile[Length] = '\0';
  if (unlink (tempfile) != 0)
    cqprint("CUNLINK: Can't unlink");
#endif /* VMS */
}
#ifndef VMS                     /* we'll use the Fortran version in VMS*/
#if CALL_LIKE_HPUX
  void ccpal1 (routne, n, type, length)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void CCPAL1 (routne, n, type, length)
#endif
#if CALL_LIKE_SUN
  void ccpal1_ (routne, n, type, length) 
#endif
  void (* routne) ();
  int *n, type[], length[];
{
  int i, size, *leng[13];
  void *pointer[13];

  for (i=0; i<*n; i++) {
    switch (type[i]) {
    case 1:
      size = item_sizes[6]; break; /* integer */
    case 2:
      size = item_sizes[2]; break; /* real */
    case 3:
      size = 2*item_sizes[2]; break; /* double */
    case 4:
      size = 2*item_sizes[2]; break; /* complex */
    case 5:
      size = item_sizes[1]; break; /* bytes (logical or integer *1) */
    }
    pointer[i+1] = calloc ((size_t) length[i], (size_t) size);
    if (pointer[i+1] == NULL) fatal ("CCPALC: can't allocate memory");
    leng[i+1] = &(length[i]);   /* convenience */
  }
  switch (*n) {
  case 1:
    (* routne) (leng[1], pointer[1]);
    break;
  case 2:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2]);
    break;
  case 3:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3]);
    break;
  case 4:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4]);
    break;
  case 5:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5]);
    break;
  case 6:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6]);
    break;
  case 7:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7]);
    break;
  case 8:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7], leng[8], pointer[8]);
    break;
  case 9:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7], leng[8], pointer[8],
                leng[9], pointer[9]);
    break;
  case 10:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7], leng[8], pointer[8],
                leng[9], pointer[9], leng[10], pointer[10]);
    break;
  case 11:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7], leng[8], pointer[8],
                leng[9], pointer[9], leng[10], pointer[10],
                leng[11], pointer[11]);
    break;
  case 12:
    (* routne) (leng[1], pointer[1], leng[2], pointer[2],
                leng[3], pointer[3], leng[4], pointer[4],
                leng[5], pointer[5], leng[6], pointer[6],
                leng[7], pointer[7], leng[8], pointer[8],
                leng[9], pointer[9], leng[10], pointer[10],
                leng[11], pointer[11], leng[12], pointer[12]);
    break;
  }
  for (i=0; i<*n; i++)
    free (pointer[i+1]);
}
#endif /* VMS */
#if CALL_LIKE_HPUX
  void copen (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void COPEN (iunit, filename, istat)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void COPEN (iunit, filename, istat)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void copen_ (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif

int  *iunit, *istat;
{
  size_t Length;
  int i, jstat;

  jstat = *istat;
  if (! initialised) {
    /* note that array element 0 is unused -- using it produced
       complaints from mtzlib about a zero stream */
    for (i = 1; i < MAXFILES; i++) {
      file_stream[i]         = NULL;
      file_name[i][0]        = '\0';
      file_bytes_per_item[i] = item_sizes[DEFMODE];  /* default item size */
      file_is_scratch[i]     = 0;
      file_last_op[i]        = IRRELEVANT_OP;
      file_mode[i] = DEFMODE;
    }
    initialised = 1;
  }
  for (i = 1; i < MAXFILES; i++) /* Find next available stream */
    if (file_stream[i] == NULL) break;
  if (i == MAXFILES) {
    *iunit = -1;                /* return no more units flag */
    return;
  } else {
    *iunit = i;}                 /* will return the stream number */
#if CALL_LIKE_STARDENT
  Length = flength (filename->Str_pointer, filename->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->Str_pointer, Length);
#else
#  if defined (VMS)
  Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->dsc$a_pointer, Length);
#  else
  Length = flength (filename, Lfilename);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename, Length);
#  endif
#endif
  file_name[i][Length] = '\0';
  file_last_op[i] = IRRELEVANT_OP;
  file_bytes_per_item[i] = item_sizes[DEFMODE]; /* default item size */
  file_mode[i] = DEFMODE;
  file_is_scratch[i] = (jstat == 2);
#ifdef VMS
  if (file_is_scratch[i])
    file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1],
                            "mbc=16", /* bigger blocksize */
                            "fop=tmd"); /* temporary, delete on close */
  else
    file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1],
                            "mbc=16", /* bigger blocksize */
                            "ctx=stm", "mrs=0", "rat=cr", "rfm=stmlf");
#else
  file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1]);
  if (file_is_scratch[i] && unlink (file_name[i])!=0)
    fatal ("(Q)QOPEN: error unlinking scratch file");
#endif
  if (file_stream[i] == NULL) {
    *iunit = -2;                /* return open failure flag */
    return; }
  Iconvert[i] = Fconvert[i] = 0;
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
  if (fseek (file_stream[*iunit], 0L, SEEK_SET) != 0)
    fatal("(Q)QOPEN: fseek failed");
  *iunit = i;
}
#if CALL_LIKE_HPUX
  void qrarch (iunit, ipos, ireslt)
#endif
#if CALL_LIKE_STARDENT
  void QRARCH (iunit, ipos, ireslt)
#endif
#if defined (VMS)
  void QRARCH (iunit, ipos, ireslt)
#endif
#if CALL_LIKE_SUN
  void qrarch_ (iunit, ipos, ireslt)
#endif
  int *ipos, *ireslt, *iunit;
{
  uint16 fileFT, fileIT;        /* float and integer machine types of file */
  unsigned char mtstring[4];    /* machine stamp */
  char *native = getenv ("NATIVEMTZ");
  char *foreign = getenv ("CONVERT_FROM");

  if (native != NULL) { *ireslt = 0; return; }
  if (foreign != NULL) {
    if (strcmp (foreign, "BEIEEE") == 0) {
      mtstring[0] = DFNTF_BEIEEE | (DFNTF_BEIEEE << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "LEIEEE") == 0) {
      mtstring[0] = DFNTF_LEIEEE | (DFNTF_LEIEEE << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "VAX") == 0) {
      mtstring[0] = DFNTF_VAX | (DFNTF_VAX << 4);
      mtstring[1] = 1 | (DFNTI_IBO << 4); }
    else if (strcmp (foreign, "CONVEXNATIVE") == 0) {
      mtstring[0] = DFNTF_CONVEXNATIVE | (DFNTF_CONVEXNATIVE << 4);
      mtstring[1] = 1 | (DFNTI_MBO << 4); }  
  } else {
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    if ((fseek (file_stream[*iunit], (size_t) ((*ipos)*item_sizes[2]),
                SEEK_SET) != 0))
      fatal ("QRARCH: seek failed");
    file_last_op[*iunit] = READ_OP;
    if (fread (mtstring, (size_t) sizeof(char), (size_t) 4,
               file_stream[*iunit]) != 4)
      fatal ("QRARCH: can't read machine stamp");
  }
  fileIT = (mtstring[1]>>4) & 0x0f;
  fileFT = (mtstring[0]>>4) & 0x0f;
  /* Record the need for conversion and what the file type is: */
  if (fileFT != 0 && fileFT != nativeFT)
    Fconvert[*iunit] = fileFT;  /* else assume native */
  if (fileIT != 0 && fileIT != nativeIT)
    Iconvert[*iunit] = fileIT;  /* else assume native */
  *ireslt = fileFT + (16*fileIT);
}
#if CALL_LIKE_HPUX
  void qwarch (iunit, ipos)
#endif
#if CALL_LIKE_STARDENT
  void QWARCH (iunit, ipos)
#endif
#if defined (VMS)
  void QWARCH (iunit, ipos)
#endif
#if CALL_LIKE_SUN
  void qwarch_ (iunit, ipos)
#endif
  int *ipos, *iunit;
{
  unsigned char mtstring[4];    /* machine stamp */
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
  if (fseek (file_stream[*iunit], (size_t) ((*ipos)*item_sizes[2]),
             SEEK_SET) != 0)
    fatal ("QWARCH: seek failed");
  /* nibbles packed by masking and ORing: */
  mtstring[0] = nativeFT | (nativeFT << 4);
  mtstring[1] = 1 | (nativeIT << 4);
  mtstring[2] = mtstring[3] = 0;
  file_last_op[*iunit] = WRITE_OP;
  if (fwrite (mtstring, (size_t) sizeof(char), (size_t) 4,
             file_stream[*iunit]) != 4)
    fatal ("QWARCH: can't write machine stamp");
}
#if CALL_LIKE_HPUX
  void qclose (iunit)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QCLOSE (iunit)
#endif
#if CALL_LIKE_SUN
  void qclose_ (iunit)
#endif

int *iunit;
{
  int l;
  if (! initialised) 
    fatal ("QCLOSE: qopen/qqopen not yet called");
  if (file_stream[*iunit] != NULL) {
    if (fclose (file_stream[*iunit]) == EOF) 
      fatal ("QCLOSE: failed"); /* fixme: add file name to message */
    file_stream[*iunit] = NULL;
  }
  file_name[*iunit][0] = '\0';
}
#if CALL_LIKE_HPUX
  void qmode (iunit, mode, size)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QMODE (iunit, mode, size)
#endif
#if CALL_LIKE_SUN
  void qmode_ (iunit, mode, size)
#endif

int *iunit, *mode, *size;
{
  if (! initialised) 
    fatal ("QMODE: qopen/qqopen not yet called");

  if (*mode >= 0 && *mode <= 6 && *mode != 5)
    file_bytes_per_item[*iunit] = item_sizes[*mode];
  else
    fatal ("QMODE: bad mode");
  *size = file_bytes_per_item[*iunit];       /* return number of bytes/item */
  file_mode[*iunit] = *mode;
}
#if CALL_LIKE_HPUX
  void qread (iunit, buffer, nitems, result)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QREAD (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_SUN
  void qread_ (iunit, buffer, nitems, result)
#endif

uint8 * buffer;
int *iunit, *nitems, *result;
{
  int i, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP) {
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      /**result = -1;*/
      fatal ("QREAD: seek error");
      return; } }
  file_last_op[*iunit] = READ_OP;
  errno = 0;
  i = fread (buffer, (size_t) file_bytes_per_item[*iunit], 
                (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) {
    if (feof (file_stream[*iunit])) *result = -1;
    else {
      /**result = i;*/
      fatal ("QREAD: i/o error");
      return;
    }
  }
  *result = 0;
  n = *nitems;
    switch (file_mode[*iunit]) {
    case BYTE:
      break;
    case INT16:
      if (Iconvert[*iunit])
        {
        if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
            (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO)) {
          char j;
          for (i=0; i < n*2; i+=2) {
            j = buffer[i];
            buffer[i] = buffer[i+1];
            buffer[i+1] = j; } }
        else
          fatal("QREAD: bad file integer type in conversion");
        }
      break;
    case INT32:
      if (Iconvert[*iunit])
        {
        if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
            (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO))
          {
            char j;
            for (i=0; i < n*4; i+=4) {
              j = buffer[i];
              buffer[i] = buffer[i+3];
              buffer[i+3] = j;
              j = buffer[i+1];
              buffer[i+1] = buffer[i+2];
              buffer[i+2] =j; }
          }
        else
          fatal("QREAD: bad file integer type in conversion");
        }
      break;
    case FLOAT32:
      if (Fconvert[*iunit])
        {
        switch (Fconvert[*iunit]) {     /* get to BE IEEE */
           case DFNTF_VAX :
             vaxF2ieeeF(buffer, n);
             break;   
           case DFNTF_CONVEXNATIVE :
             convexF2ieeeF(buffer, n);
             break;
           case DFNTF_BEIEEE :
             break;
           case DFNTF_LEIEEE :
             {
               char j;
               for (i=0; i < n*4; i+=4) {
                 j = buffer[i];
                 buffer[i] = buffer[i+3];
                 buffer[i+3] = j;
                 j = buffer[i+1];
                 buffer[i+1] = buffer[i+2];
                 buffer[i+2] =j; }
             }
             break;
           default :
             fatal("QREAD: bad file real type in conversion");
           }
        switch (nativeFT) {
          case DFNTF_BEIEEE :
            break;                      /* done enough */
          case DFNTF_LEIEEE :
            {
              char j;
              for (i=0; i < n*4; i+=4) {
                j = buffer[i];
                buffer[i] = buffer[i+3];
                buffer[i+3] = j;
                j = buffer[i+1];
                buffer[i+1] = buffer[i+2];
                buffer[i+2] =j; }
            }
            break;
          case DFNTF_CONVEXNATIVE :
            ieeeF2convexF(buffer, n);
            break;
          case DFNTF_VAX :
            ieeeF2vaxF(buffer, n);
            break;
          default :
            fatal("QREAD: bad native real type in conversion");
          }
        }
      break;
    case COMP32:
      if (Fconvert[*iunit]) {
        n = 2*n;                  /* pairs of ints */
        {
        if ((Iconvert[*iunit]==DFNTI_MBO && nativeIT==DFNTI_IBO) ||
            (Iconvert[*iunit]==DFNTI_IBO && nativeIT==DFNTI_MBO)) {
          char j;
          for (i=0; i < n*2; i+=2) {
            j = buffer[i];
            buffer[i] = buffer[i+1];
            buffer[i+1] = j; } }
        else
          fatal("QREAD: bad file integer type in conversion");
        }
      }
      break;
    case COMP64:
      if (Fconvert[*iunit]) {
        n = 2*n;                  /* pairs of reals */
        {
        switch (Fconvert[*iunit]) {     /* get to BE IEEE */
           case DFNTF_VAX :
             vaxF2ieeeF(buffer, n);
             break;   
           case DFNTF_CONVEXNATIVE :
             convexF2ieeeF(buffer, n);
             break;
           case DFNTF_BEIEEE :
             break;
           case DFNTF_LEIEEE :
             {
               char j;
               for (i=0; i < n*4; i+=4) {
                 j = buffer[i];
                 buffer[i] = buffer[i+3];
                 buffer[i+3] = j;
                 j = buffer[i+1];
                 buffer[i+1] = buffer[i+2];
                 buffer[i+2] =j; }
             }
             break;
           default :
             fatal("QREAD: bad file real type in conversion");
           }
        switch (nativeFT) {
          case DFNTF_BEIEEE :
            break;                      /* done enough */
          case DFNTF_LEIEEE :
            {
              char j;
              for (i=0; i < n*4; i+=4) {
                j = buffer[i];
                buffer[i] = buffer[i+3];
                buffer[i+3] = j;
                j = buffer[i+1];
                buffer[i+1] = buffer[i+2];
                buffer[i+2] =j; }
            }
            break;
          case DFNTF_CONVEXNATIVE :
            ieeeF2convexF(buffer, n);
            break;
          case DFNTF_VAX :
            ieeeF2vaxF(buffer, n);
            break;
          default :
            fatal("QREAD: bad native real type in conversion");
          }
        }
      }
      break;
    default:
      fatal ("QREAD: Bad mode");
    }
}
#if CALL_LIKE_HPUX
  void qreadc (iunit, buffer, result, Lbuffer)
  int Lbuffer;
  char * buffer;
#endif
#ifdef VMS
  void QREADC (iunit, buffer, result)
  struct dsc$descriptor_s *buffer;
#endif
#if CALL_LIKE_STARDENT
  void QREADC (iunit, buffer, result)
  struct Str_Desc *buffer;
#endif
#if CALL_LIKE_SUN
  void qreadc_ (iunit, buffer, result, Lbuffer)
  int Lbuffer;
  char * buffer;
#endif

int *iunit, *result;
{
  int i, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP) {
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      *result = -1;
      return; } }
  file_last_op[*iunit] = READ_OP;
#if defined (VMS)
  n = buffer->dsc$w_length;
  i = fread (buffer->dsc$a_pointer, (size_t) item_sizes[BYTE], 
                (size_t) n, file_stream[*iunit]);
#else
#  if CALL_LIKE_STARDENT
  n = buffer->Str_length;
  i = fread (buffer->Str_pointer, (size_t) item_sizes[BYTE], 
                (size_t) n, file_stream[*iunit]);
#  else                         /* normal */
  n = Lbuffer;
  i = fread (buffer, (size_t) item_sizes[BYTE], 
                (size_t) n, file_stream[*iunit]);
#  endif
#endif
  if (i != n) {
    if (feof (file_stream[*iunit])) *result = -1;
    else *result = i;
    return;
  }
  *result = 0;
}
#if CALL_LIKE_HPUX
  void qwrite (iunit, buffer, nitems)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QWRITE (iunit, buffer, nitems)
#endif
#if CALL_LIKE_SUN
  void qwrite_ (iunit, buffer, nitems)
#endif
uint8 * buffer;
int *iunit, *nitems;
{
  int i;

  if (! initialised) 
    fatal ("QWRITE: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP) {
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITE: seek failed"); }
  file_last_op[*iunit] = WRITE_OP;
  i = (int) fwrite (buffer, (size_t) file_bytes_per_item[*iunit],
                    (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) fatal ("QWRITE: i/o error (may be out of disc space)");
}
#if CALL_LIKE_HPUX
  void qwritc (iunit, buffer, Lbuffer)
  int Lbuffer;
  char * buffer;
#endif
#if defined (VMS)
  void QWRITC (iunit, buffer)
  struct dsc$descriptor_s *buffer;
#endif
#if defined CALL_LIKE_STARDENT
  void QWRITC (iunit, buffer)
  struct Str_Desc *buffer;
#endif
#if CALL_LIKE_SUN
  void qwritc_ (iunit, buffer, Lbuffer)
  int Lbuffer;
  char * buffer;
#endif
int *iunit;
{
  int i, n;

  if (! initialised) 
    fatal ("QWRITC: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP) {
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITC: seek failed"); }
  file_last_op[*iunit] = WRITE_OP;
#if defined (VMS)
  n = buffer->dsc$w_length;
  i = (int) fwrite (buffer->dsc$a_pointer, (size_t) item_sizes[BYTE],
                    (size_t) n, file_stream[*iunit]);
#else
#  if CALL_LIKE_STARDENT
  n = buffer->Str_length;
  i = (int) fwrite (buffer->Str_pointer, (size_t) item_sizes[BYTE],
                    (size_t) n, file_stream[*iunit]);
#  else                         /* normal */
  n = Lbuffer;
#  endif
#endif
  i = (int) fwrite (buffer, (size_t) item_sizes[BYTE],
                    (size_t) n, file_stream[*iunit]);
  if (i != n) fatal ("QWRITC: i/o error (may be out of disc space)");
}
#if CALL_LIKE_HPUX
  void qseek (iunit, irec, iel, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QSEEK (iunit, irec, iel, lrecl)
#endif
#if CALL_LIKE_SUN
  void qseek_ (iunit, irec, iel, lrecl)
#endif

int *iunit, *irec, *iel, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSEEK: qopen/qqopen not yet called");
  position = (long) ((*lrecl)*(*irec - 1) + (*iel - 1));
  position *= (long) file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSEEK failed -- maybe corrupt file."); /* fixme: add file info */
}
#if CALL_LIKE_HPUX
  void qback (iunit, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QBACK (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qback_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QBACK: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) - (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
  if (fseek (file_stream[*iunit], position, SEEK_SET) != 0)
    fatal ("QBACK failed");     /* fixme: add file info */
}
#if CALL_LIKE_HPUX
  void qskip (iunit, lrecl)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QSKIP (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qskip_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSKIP: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) +
    (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSKIP failed");     /* fixme: add file info */
}
#if CALL_LIKE_HPUX
  void cqinq (istrm, filnam, length, len_filnam)
  char *filnam; 
  int len_filnam;
#endif
#if CALL_LIKE_STARDENT
  void CQINQ (istrm, filnam, length)
  struct Str_Desc *filnam;
#endif
#if defined (VMS)
  void CQINQ (istrm, filnam, length)
  struct dsc$descriptor_s *filnam;
#endif
#if CALL_LIKE_SUN
  void cqinq_ (istrm, filnam, length, len_filnam)
  char *filnam;
  int len_filnam;
#endif

int *istrm, *length;
{
  char real_name[MAXFLEN];
  int *iunit, Length, i;
  long position;

  if (! initialised) 
    fatal ("QQINQ:,qopen/qqopen not yet called");
  *length = -1;                                    /* default return value */
  iunit = istrm;
  if (file_stream[*iunit] == NULL) { 
    /* no unit open -- try file name */
#if CALL_LIKE_STARDENT
    Length = flength (filnam->Str_pointer, filnam->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (real_name, filnam->Str_pointer, Length);
#else
#  if defined (VMS)
     Length = flength (filnam->dsc$a_pointer, filnam->dsc$w_length);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam->dsc$a_pointer, Length);
#  else
     Length = flength (filnam, len_filnam);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam, Length);
#  endif
#endif
    real_name[Length] = '\0';
    for (i = 1; i < MAXFILES; i++)
      if (! strcmp (real_name, file_name[i])) break;
    *iunit = i % MAXFILES;
  }
  if (file_stream[*iunit] != NULL) {
    file_last_op[*iunit] = IRRELEVANT_OP;
    (void) fflush (file_stream[*iunit]); /* flush the output stream */
#if 0
    /* checking the return value reportedly causes problems in ultrix
       under unknown circumstances... */
    if (fflush (file_stream[*iunit]) != 0) fatal ("QQINQ: flush failed");
#endif
    position = ftell (file_stream[*iunit]);   /* remember current position */
#if defined (__alpha) && defined (vms)
(void) fflush (file_stream[*iunit]);
#endif
    (void) fseek (file_stream[*iunit],0L,SEEK_END); /* seek EOF */
    *length = (int) ftell (file_stream[*iunit]); /* get file size */
    if (fseek (file_stream[*iunit],position,SEEK_SET) != 0) /* seek position */
      fatal ("QQINQ: seek failed"); /* fixme: add file info */
  }
}
#if CALL_LIKE_HPUX
  void qlocate (iunit, locate)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QLOCATE (iunit, locate)
#endif
#if CALL_LIKE_SUN
  void qlocate_ (iunit, locate)
#endif

int *iunit, *locate;
{
  if (! initialised) 
    fatal ("QLOCATE: qopen/qqopen not yet called");
  *locate = -1;
  if (file_stream[*iunit] != NULL)
    *locate = (int) ftell (file_stream[*iunit]) / file_bytes_per_item[*iunit];
}
#ifdef _AIX
void idate (iarray)
     int iarray[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     iarray[0] = lt->tm_mday;
     iarray[1] = lt->tm_mon+1;  /* need range 1-12 */
     iarray[2] = lt->tm_year + 1900;
}
#endif
#if defined (__hpux) || defined (_AIX)
void gerror (str, Lstr)
char *str;
int  Lstr;
{
  int i;

  if (errno == 0) {             /* Avoid `Error 0' or some such message */
    for (i=1; Lstr; i++)
      str[i] = ' ';
  } else {
    (void) strncpy (str, strerror (errno), Lstr);
    for (i = strlen (str); i < Lstr; i++) str[i] = ' ';  /* pad with spaces */
  }
} /* End of gerror (str, Lstr) */

int ierrno () {
  return errno;
}

void itime (array)
     int array[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     array[0] = lt->tm_hour; array[1] = lt->tm_min; array[2] = lt->tm_sec;
}

static long clk_tck = 0;

#if 0                           /* dtime isn't used at present */
float dtime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  static time_t old_utime = 0, old_stime = 0;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  utime = buffer.tms_utime; stime = buffer.tms_stime;
  tarray[0] = ((float)(utime - old_utime)) / (float)clk_tck;
  tarray[1] = ((float)(stime - old_stime)) / (float)clk_tck;
  old_utime = utime; old_stime = stime;
  return (tarray[0]+tarray[1]);
}
#endif                          /* dtime */

float etime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  tarray[0] = (float) buffer.tms_utime / (float)clk_tck;
  tarray[1] = (float) buffer.tms_stime / (float)clk_tck;
  return (tarray[0]+tarray[1]);
}

#endif  /* AIX || HPUX */
#if defined(F2C) || defined(G77)
int exit_ (status)
     int *status;
{
  f_exit ();                    /* may or may not be registered with
                                   exit, depending on the C libraries
                                   capabilities, but is idempotent */
  exit (*status);
}

int time_ ()
{
  return (int) time (NULL);
}

int getpid_ ()
{
  return (int) getpid ();
}

/* following are from libI77/fio.h */
#define MXUNIT 100
typedef int flag;
typedef struct
{       FILE *ufd;      /*0=unconnected*/
        char *ufnm;
        long uinode;
        int udev;
        int url;        /*0=sequential*/
        flag useek;     /*true=can backspace, use dir, ...*/
        flag ufmt;
        flag uprnt;
        flag ublnk;
        flag uend;
        flag uwrt;      /*last io was write*/
        flag uscrtch;
} unit;
extern unit f__units[];
#define TRUE_ (1)
#define FALSE_ (0)
#define err(f,m,s) {if(f) errno= m; else f__fatal(m,s); return(m);}
/* end of fio.h extract */

int isatty_ (lunit)
     int *lunit;
{
  if (*lunit>=MXUNIT || *lunit<0)
    err(1,101,"isatty");
  /* f__units is a table of descriptions for the unit numbers (defined
     in io.h) with file descriptors rather than streams */
  return (isatty(fileno((f__units[*lunit]).ufd)) ? TRUE_ : FALSE_);
}

int idate_ (iarray)
     int iarray[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     iarray[0] = lt->tm_mday;
     iarray[1] = lt->tm_mon+1;  /* need range 1-12 */
     iarray[2] = lt->tm_year + 1900;
     return 0;
}

int gerror_ (str, Lstr)
char *str;
int  Lstr;
{
  int i;

  if (errno == 0) {             /* Avoid `Error 0' or some such message */
    for (i=1; Lstr; i++)
      str[i] = ' ';
  } else {
    (void) strncpy (str, strerror (errno), Lstr);
    for (i = strlen (str); i < Lstr; i++) str[i] = ' ';  /* pad with spaces */
  }
  return 0;
}

int ierrno_ () {
  return errno;
}

int itime_ (array)
     int array[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     array[0] = lt->tm_hour; array[1] = lt->tm_min; array[2] = lt->tm_sec;
     return 0;
}

static long clk_tck = 0;

float etime_ (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  tarray[0] = (float) buffer.tms_utime / (float)clk_tck;
  tarray[1] = (float) buffer.tms_stime / (float)clk_tck;
  return (tarray[0]+tarray[1]);
}
int /* integer */ ibset_ (a, b)
     int /* integer */ *a, *b;
{
  return (*a) | 1<<(*b);
}

int /* integer */ ibclr_ (a, b)
     int /* integer */ *a, *b;
{
  return (*a) & ~(1<<(*b));
}

int /* logical */ btest_ (a, b)
     int /* integer */ *a, *b;
{
  return ((((unsigned long) *a)>>(*b)))&1 ? TRUE_ : FALSE_;
}
#endif  /* F2C || g77 */
#if CALL_LIKE_HPUX
  void cnan (real)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void CNAN (real)
#endif
#if CALL_LIKE_SUN
  void cnan_ (real)
#endif
  union float_uint_uchar *real;
#if NATIVEFT == DFNTF_BEIEEE || NATIVEFT == DFNTF_LEIEEE
#  define NAN 0xfffa5a5a
#endif
#if NATIVEFT == DFNTF_CONVEXNATIVE
#  define NAN 0x80000000
#endif
#if NATIVEFT == DFNTF_VAX
#  define NAN 0x00008000
#endif
#ifndef NAN
  #error "NAN isn't defined (needs NATIVEFT)"
#endif
{
  real->i = NAN;
}
#if CALL_LIKE_HPUX
  int cisnan (real)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  int CISNAN (real)
#endif
#if CALL_LIKE_SUN
  int cisnan_ (real)
#endif
  union float_uint_uchar *real;
{
    switch (nativeFT) {
     case DFNTF_BEIEEE :
     case DFNTF_LEIEEE :
       return ((real->i & 0x7f800000) == 0x7f800000); /* exponent all 1s */
      case DFNTF_CONVEXNATIVE :
        return ((real->i & 0xff800000) == 0x80000000);      
      case DFNTF_VAX :
        return ((real->i & 0x0000ff80) == 0x00008000);
      default :
        fatal("CISNAN: bad nativeFT");  }
}
#define MDFBIG -1.0E10          /* BIOMOL absence flag value */
#if CALL_LIKE_HPUX
  void ccpbml (ncols, cols)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void CCPBML (ncols, cols)
#endif
#if CALL_LIKE_SUN
  void ccpbml_ (ncols, cols)
#endif
  int *ncols;
  union float_uint_uchar cols[];
{
  int i;
  for (i=0; i<*ncols; i++)
    if (cols[i].i != NAN)
      if (cols[i].f <= MDFBIG) cols[i].f = 0.0;
}
#if CALL_LIKE_HPUX
  void ccpwrg (ncols, cols, wminmax)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void CCPWRG (ncols, cols, wminmax)
#endif
#if CALL_LIKE_SUN
  void ccpwrg_ (ncols, cols, wminmax)
#endif
  int *ncols;
  float wminmax[];
  union float_uint_uchar cols[];
{
  int i;
  for (i=0; i<*ncols; i++)
    if (cols[i].i != NAN)
       if (cols[i].f > MDFBIG) {
         if (cols[i].f < wminmax[2*i]) wminmax[2*i] = cols[i].f;
         if (cols[i].f > wminmax[1+2*i]) wminmax[1+2*i] = cols[i].f; }
}
#endif

