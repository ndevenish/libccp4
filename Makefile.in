
# Makefile tail for CCP4 Library.  This will be modified by configure.

# $Id$

# Usage: make                 - to make the library in this directory
#        make <module>        - to make that particular module
#        make install         - to copy the results into binary directory
#        make test            - to compile and run the library testbed

# This is horrible in the hope of being able to cater for all makes
# and still have the advantage of not re-making the library
# un-necessarily without sentinel files.  A combination of makes not
# understanding VPATH and not dealing with foo(bar) targets well and
# the fact that the Fortran sources are stored as .for means that we
# need to do everything explicitly -- ugh.  Note that we do assume
# that the make recognises a target foo.a(bar.o) as a library member.
# Life would be so much easier if we could rely on using GNU make; I
# wonder whether we should distribute it...

# The modules in the library are mostly individual Fortran routines
# and the results of compiling whole C source files.  We don't put
# whole fortran modules in as a monolithic .o file because that can
# make the linked programs larger and also causes problems (at least
# on Convex) with multiple symbol definitions where programs define a
# routine of a name already in the library and other routines from
# that module are called.  Thus most of the targets are built like
# this; for module foo:
#
# * rm any existing foo.dir and create a new one;
# * cd into foo.dir and fsplit the source file into it;
# * compile .o files from *.f;
# * establish a dummy `sentinel' file foo.o in the library.  This
#   seems perferable to me to leaving sentinel files around in the
#   source directory.  (The sentinel is made last to avoid problems if
#   the make is interrupted.)  My original tactic of using an empty
#   file doesn't work in AIX because it isn't in object format ;
# * ar *.o into ../libccp4.a;
# * rm *.o from foo.dir (we want to leave *.f there so you can do
#   symbolic debug, see below).
# The individual files are actually compiled with a separate $(FC)
# invocation for each, rather than using *.f.)  This may slow things
# down significantly, but means we can and also include the absolute
# path for symbolic debugging without risking an overly-long command
# line that may break sh.

# The following variables are expected to be set by configure:
# top_srcdir libdir bindir FC FFLAGS CC CFLAGS RANLIB LNS M4 F
# INSTALL_PROGRAM INSTALL_DATA SHARE_LIB SHARE_INST

SHELL       = /bin/sh
srcdir	    = $(top_srcdir)/lib/src
LIB_DIR     = .
L           = $(LIB_DIR)/libccp4.a#        convenient abbreviation only
fsplit_dir  = $(srcdir)#directory where fsplit has been made/lives

# The following is for the benefit of Alliant, which is the only
# system I know where you can't use -L to specify the load path.
# (This works since make variables are defined in the environment in
# Alliant (GNU) make.)  We'd like to use $(LIB_DIR) instead of `.'
# here, but can't since that would require `:=' instead of `=' and
# confuse other makes.
LD_PATH = . /lib /usr/lib /usr/local/lib

# how to add a member to an archive (second and first args
# respectively); this might need to be set by configure:
AR          = ar r

# On some systems (Concentrix, for instance), for files with trailing
# comments, fsplit generates a file containing only comments and the
# compiler barfs on it.  Here's an abbreviation for deleting any such
# files generated, assuming two possible forms of the name generated:
# caveat naming routines!  Always use this after fsplit for safety...
RMEMPTY = rm -f ZZZ*.$(F) zzz*.$(F)

# modules to go in libccp4.a:
LIBTARGETS = $(CIFLIBTARGETS) ccplib fftlib maplib parser rwbrook modlib \
           symlib lgglib harvlib mtzlib diskio unix plot84lib libhtml \
           binsortint library library_f plotsubs keyparse pack_f pack_c \
           pxxml

.PRECIOUS : $L # don't zap the library if a component fails

# for some reason the SysVile make insists on re-building the `unix' target
# each time unless we zap the default suffixes -- gmake doesn't.  give it a
# dummy one to avoid a `No suffixes.' message
.SUFFIXES:
.SUFFIXES:	.dummy

# probably only recognised by GNU make:
.PHONY : all clean install $(LIBTARGETS) ranlib realclean distclean \
         test help test-lib uninstall tags

all :  $L

$L : $(CIFLIBOBJS) $L(ccplib.o) $L(fftlib.o) $L(maplib.o) $L(parser.o) \
	  $L(rwbrook.o) $L(modlib.o) $L(symlib.o) \
	  $L(mtzlib.o) $L(lgglib.o) $L(harvlib.o) $L(diskio.o) $L(unix.o) \
	  $L(binsortint.o) $L(library.o) $L(library_f.o) $L(plot84lib.o) \
	  $L(libhtml.o) $L(plotsubs.o) $L(keyparse.o) \
	  $L(pack_c.o) $L(pack_f.o) $L(pxxml.o)
# titan special:
	-(test -f /usr/lib/fortran/time.o && $(MAKE) '$L(time.o)') || true
# we could presumably avoid the next two steps if we haven't changed anything
	$(RANLIB) $@
# maybe create shared library
	$(SHARE_LIB)

test-lib : $(srcdir)/testlib.f $L(library.o) $L(library_f.o) $L(unix.o) $L(ccplib.o) \
	$L(diskio.o)
# titan special:
	-(test -f /usr/lib/fortran/time.o && $(MAKE) '$L(time.o)') || true
	$(RANLIB) $L

#test to see if fsplit is in fsplit_dir already otherwise make it if you can
fsplit : $(srcdir)/fsplit.c
	test ! -x $(fsplit_dir)/fsplit && $(CC) -o $(fsplit_dir)/fsplit fsplit.c || true 

# explicit building of the real targets, sigh...
# include the pwd info for ease of symbolic debugging

$L(ccplib.o) : $(srcdir)/ccplib.f
	-rm -rf ccplib.dir; mkdir ccplib.dir
	echo '      SUBROUTINE CCPLIB' > ccplib.dir/ccplib.$F
	echo '      END' >> ccplib.dir/ccplib.$F
	cd ccplib.dir && $(fsplit_dir)/fsplit $(srcdir)/ccplib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done \
	    && $(AR) ../$L *.o
	rm -f ccplib.dir/*.o
ccplib : $L(ccplib.o)
	$(RANLIB) $L

$L(fftlib.o) : $(srcdir)/fftlib.f
	-rm -rf fftlib.dir; mkdir fftlib.dir
	echo '      SUBROUTINE FFTLIB' > fftlib.dir/fftlib.$F
	echo '      END' >> fftlib.dir/fftlib.$F
	cd fftlib.dir && $(fsplit_dir)/fsplit $(srcdir)/fftlib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done \
	  && $(AR) ../$L *.o
	rm -f fftlib.dir/*.o
fftlib : $L(fftlib.o)
	$(RANLIB) $L

$L(maplib.o) : $(srcdir)/maplib.f
	-rm -rf maplib.dir; mkdir maplib.dir
	echo '      SUBROUTINE MAPLIB' > maplib.dir/maplib.$F
	echo '      END' >> maplib.dir/maplib.$F
	cd maplib.dir && $(fsplit_dir)/fsplit $(srcdir)/maplib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f maplib.dir/*.o
maplib : $L(maplib.o)
	$(RANLIB) $L

$L(parser.o) : $(srcdir)/parser.f
	-rm -rf parser.dir; mkdir parser.dir
	cd parser.dir && $(fsplit_dir)/fsplit $(srcdir)/parser.f && $(RMEMPTY);
# `-' for convex, sigh
	-if test ! -f parser.dir/parser.$F; then \
	  echo '      SUBROUTINE PRSER' > parser.dir/parser.$F; \
	  echo '      END' >> parser.dir/parser.$F; \
	fi
	cd parser.dir && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f parser.dir/*.o
parser : $L(parser.o)
	$(RANLIB) $L

$L(rwbrook.o) : $(srcdir)/rwbrook.f
	-rm -rf rwbrook.dir; mkdir rwbrook.dir
	echo '      SUBROUTINE RWBROOK' > rwbrook.dir/rwbrook.$F
	echo '      END' >> rwbrook.dir/rwbrook.$F
	cd rwbrook.dir && $(fsplit_dir)/fsplit $(srcdir)/rwbrook.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f rwbrook.dir/*.o
rwbrook : $L(rwbrook.o)
	$(RANLIB) $L

$L(modlib.o) : $(srcdir)/modlib.f
	-rm -rf modlib.dir; mkdir modlib.dir
	echo '      SUBROUTINE MODLIB' > modlib.dir/modlib.$F
	echo '      END' >> modlib.dir/modlib.$F
	cd modlib.dir && $(fsplit_dir)/fsplit $(srcdir)/modlib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f modlib.dir/*.o
modlib : $L(modlib.o)
	$(RANLIB) $L

$L(symlib.o) : $(srcdir)/symlib.f
	-rm -rf symlib.dir; mkdir symlib.dir
	echo '      SUBROUTINE SYMLIB' > symlib.dir/symlib.$F
	echo '      END' >> symlib.dir/symlib.$F
	cd symlib.dir && $(fsplit_dir)/fsplit $(srcdir)/symlib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f symlib.dir/*.o
symlib : $L(symlib.o)
	$(RANLIB) $L

$L(mtzlib.o) : $(srcdir)/mtzlib.f $(srcdir)/mtzlib.fh
	-rm -rf mtzlib.dir; mkdir mtzlib.dir
	echo '      SUBROUTINE MTZLIB' > mtzlib.dir/mtzlib.$F
	echo '      END' >> mtzlib.dir/mtzlib.$F
	cd mtzlib.dir && $(fsplit_dir)/fsplit $(srcdir)/mtzlib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) -I$(srcdir) $$i; done\
	  && $(AR) ../$L *.o
	rm -f mtzlib.dir/*.o
mtzlib : $L(mtzlib.o)
	$(RANLIB) $L

$L(lgglib.o) : $(srcdir)/lgglib.f
	-rm -rf lgglib.dir; mkdir lgglib.dir
	echo '      SUBROUTINE LGGLIB' > lgglib.dir/lgglib.$F
	echo '      END' >> lgglib.dir/lgglib.$F
	cd lgglib.dir && $(fsplit_dir)/fsplit $(srcdir)/lgglib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f lgglib.dir/*.o
lgglib : $L(lgglib.o)
	$(RANLIB) $L

$L(harvlib.o) : $(srcdir)/harvlib.f $(srcdir)/harvest.inc $(srcdir)/harderiv.inc $(srcdir)/harshell.inc $(srcdir)/harsymm.inc
	-rm -rf harvlib.dir; mkdir harvlib.dir
	echo '      SUBROUTINE HARVLIB' > harvlib.dir/harvlib.$F
	echo '      END' >> harvlib.dir/harvlib.$F
	cd harvlib.dir && $(fsplit_dir)/fsplit $(srcdir)/harvlib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) -I$(srcdir) $$i; done\
          && $(AR) ../$L *.o
	rm -f harvlib.dir/*.o
harvlib : $L(harvlib.o)
	$(RANLIB) $L

$L(cciflib.o) : $(srcdir)/cciflib.f $(srcdir)/cciflib.fh
	-rm -rf cciflib.dir; mkdir cciflib.dir
	echo '      SUBROUTINE CCIFLIB' > cciflib.dir/cciflib.$F
	echo '      END' >> cciflib.dir/cciflib.$F
	cd cciflib.dir && $(fsplit_dir)/fsplit $(srcdir)/cciflib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) -I$(srcdir) $$i; done\
          && $(AR) ../$L *.o
	rm -f cciflib.dir/*.o
cciflib : $L(cciflib.o)
	$(RANLIB) $L

$L(diskio.o) : $(srcdir)/diskio.f
	-rm -rf diskio.dir; mkdir diskio.dir
	echo '      SUBROUTINE DISKIO' > diskio.dir/diskio.$F
	echo '      END' >> diskio.dir/diskio.$F
	cd diskio.dir && $(fsplit_dir)/fsplit $(srcdir)/diskio.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f diskio.dir/*.o
diskio : $L(diskio.o)

$L(plot84lib.o) : $(srcdir)/plot84lib.f
	-rm -rf plot84lib.dir; mkdir plot84lib.dir
	echo '      SUBROUTINE PLOT84LIB' > plot84lib.dir/plot84lib.$F
	echo '      END' >> plot84lib.dir/plot84lib.$F
	cd plot84lib.dir && $(fsplit_dir)/fsplit $(srcdir)/plot84lib.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f plot84lib.dir/*.o
plot84lib : $L(plot84lib.o)
	$(RANLIB) $L

$L(libhtml.o) : $(srcdir)/libhtml.f
	-rm -rf libhtml.dir; mkdir libhtml.dir
	echo '      SUBROUTINE LIBHTML' > libhtml.dir/libhtml.$F
	echo '      END' >> libhtml.dir/libhtml.$F
	cd libhtml.dir && $(fsplit_dir)/fsplit $(srcdir)/libhtml.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f libhtml.dir/*.o
libhtml : $L(libhtml.o)
	$(RANLIB) $L

$L(pxxml.o) : $(srcdir)/pxxml.f
	-rm -rf pxxml.dir; mkdir pxxml.dir
	echo '      SUBROUTINE PXXML' > pxxml.dir/pxxml.$F
	echo '      END' >> pxxml.dir/pxxml.$F
	cd pxxml.dir && $(fsplit_dir)/fsplit $(srcdir)/pxxml.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f pxxml.dir/*.o
pxxml : $L(pxxml.o)
	$(RANLIB) $L

$L(plotsubs.o) : $(srcdir)/plotsubs.f
	-rm -rf plotsubs.dir; mkdir plotsubs.dir
	echo '      SUBROUTINE PLOTSUBS' > plotsubs.dir/plotsubs.$F
	echo '      END' >> plotsubs.dir/plotsubs.$F
	cd plotsubs.dir && $(fsplit_dir)/fsplit $(srcdir)/plotsubs.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f plotsubs.dir/*.o
plotsubs : $L(plotsubs.o)
	$(RANLIB) $L

# This is (currently) a single routine, so don't fsplit
$L(keyparse.o) : $(srcdir)/keyparse.f
	$(FC) -c -o keyparse.o $(FFLAGS) $(srcdir)/keyparse.f && \
		$(AR) $L keyparse.o && rm -f keyparse.o
	$(RANLIB) $L
keyparse : $L(keyparse.o)
	$(RANLIB) $L

# C stuff: (these are kept as whole modules)

$L(library.o) : $(srcdir)/library.c $(srcdir)/library.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/library.c
	$(AR) $L library.o && rm library.o
library : $L(library.o)
	$(RANLIB) $L

$L(library_f.o) : $(srcdir)/library_f.c $(srcdir)/library.h 
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/library_f.c
	$(AR) $L library_f.o && rm library_f.o
library_f : $L(library_f.o)
	$(RANLIB) $L

$L(binsortint.o) : $(srcdir)/binsortint.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/binsortint.c
	$(AR) $L binsortint.o && rm binsortint.o
binsortint : $L(binsortint.o)
	$(RANLIB) $L

#
# specials
#

#  a program:

# the unix-specific bits need preprocessing for different unix variants
unix.f : $(srcdir)/unix.m4
	$(M4) $(srcdir)/unix.m4 >unix.f
# this shouldn't depend on unix.f since we zap that each time
$L(unix.o) : $(srcdir)/unix.m4
	$(M4) $(srcdir)/unix.m4 >unix.f
	-rm -rf unix.dir; mkdir unix.dir
	echo '      SUBROUTINE UNIX' > unix.dir/unix.f
	echo '      END' >> unix.dir/unix.f
	cd unix.dir && $(fsplit_dir)/fsplit ../unix.f >/dev/null && $(RMEMPTY) && \
	  for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
	  && $(AR) ../$L *.o
	rm -f unix.dir/*.o unix.f
unix : $L(unix.o)
	$(RANLIB) $L

#  The image (un)packing routines which were needed for mosflm and are needed
#  for ipdisp. May be useful but could be moved. 
$L(pack_c.o):	$(srcdir)/pack_c.c $(srcdir)/pack_c.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/pack_c.c
	$(AR) $L pack_c.o && rm pack_c.o
$L(pack_f.o):	$(srcdir)/pack_f.f
	$(FC) -c $(FFLAGS) $(srcdir)/pack_f.$(F) && $(AR) $(L) pack_f.o \
	  && rm pack_f.o
pack:	$L(pack_c.o) $L(pack_f.o)
	$(RANLIB) $(L) 

# Apparently titan needs to link /usr/lib/fortran/time.o.  It seems
# easiest to stuff it in the library
$L(time.o) : /usr/lib/fortran/time.o
	$(AR) $(L) /usr/lib/fortran/time.o

# testbed for library.c and some other modules:
testlib : test-lib $(srcdir)/testlib.f
	$(FC) -o testlib $(FFLAGS) $(srcdir)/testlib.f $(LDFLAGS)

#
# standard targets
#

install : all
	$(INSTALL_DATA) `pwd`/$L $(libdir)/$L
	$(RANLIB) $(libdir)/$L
	$(SHARE_INST)

uninstall :
	-rm -f $(libdir)/$L
	test -f $(libdir)/libccp4.so && rm -f $(libdir)/libccp4.so

clean :
	-rm -f core *.o *~ *.dir/*.o testlib disc.dft a.out *.orig *.rej defs.m4
	-rm -rf tagdir

realclean : clean
	-rm -rf $L *.dir TAGS unix.f libccp4.so fsplit

distclean : realclean
	-rm -f Makefile

test : testlib
	./testlib -v 3 testenv foo

tags TAGS : unix.f
	etags ${srcdir}/*.[fch] #${srcdir}/unix.m4
	sed -e 's/unix.f/unix.m4/' TAGS > TAGS.x
	mv TAGS.x TAGS
	rm -f unix.f

# Local Variables:
# mode:makefile
# End:
