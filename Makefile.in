
# Makefile tail for CCP4 Library.  This will be modified by configure.

# $Header$

# Usage: make                 - to make the library in this directory
#        make <module>        - to make that particular module
#        make binsort         - for the binsort program in this directory
#        make install         - to copy the results into binary directory
#        make test            - to compile and run the library testbed

# This is horrible in the hope of being able to cater for all makes
# and still have the advantage of not re-making the library
# un-necessarily without sentinel files.  A combination of makes not
# understanding VPATH and not dealing with foo(bar) targets well and
# the fact that the Fortran sources are stored as .for means that we
# need to do everything explicitly -- ugh.  Note that we do assume
# that the make recognises a target foo.a(bar.o) as a library member.
# Life would be so much easier if we could rely on using GNU make; I
# wonder whether we should distribute it...

# The modules in the library are mostly individual Fortran routines
# and the results of compiling whole C source files.  We don't put
# whole fortran modules in as a monolithic .o file because that can
# make the linked programs larger and also causes problems (at least
# on Convex) with multiple symbol definitions where programs define a
# routine of a name already in the library and other routines from
# that module are called.  Thus most of the targets are built like
# this; for module foo:
#
# * rm any existing foo.dir and create a new one;
# * cd into foo.dir and fsplit the source file into it;
# * compile .o files from *.f;
# * establish a dummy `sentinel' file foo.o in the library.  This
#   seems perferable to me to leaving sentinel files around in the
#   source directory.  (The sentinel is made last to avoid problems if
#   the make is interrupted.)  My original tactic of using an empty
#   file doesn't work in AIX because it isn't in object format ;
# * ar *.o into ../libccp4.a;
# * rm *.o from foo.dir (we want to leave *.f there so you can do
#   symbolic debug, see below).
# The individual files are actually compiled with a separate $(FC)
# invocation for each, rather than using *.f.)  This may slow things
# down significantly, but means we can and also include the absolute
# path for symbolic debugging without risking an overly-long command
# line that may break sh.

# The following variables are expected to be set by configure:
# top_srcdir libdir bindir FC FFLAGS CC CFLAGS RANLIB LNS M4 F
# INSTALL_PROGRAM INSTALL_DATA MAYBEMOSFLM

SHELL       = /bin/sh
srcdir	    = $(top_srcdir)/lib/src
L           = libccp4.a#        convenient abbreviation only
LIB_DIR     = .

# The following is for the benefit of Alliant, which is the only
# system I know where you can't use -L to specify the load path.
# (This works since make variables are defined in the environment in
# Alliant (GNU) make.)  We'd like to use $(LIB_DIR) instead of `.'
# here, but can't since that would require `:=' instead of `=' and
# confuse other makes.
LD_PATH = . /lib /usr/lib /usr/local/lib

# how to add a member to an archive (second and first args
# respectively); this might need to be set by configure:
AR          = ar r

# On some systems (Concentrix, for instance), for files with trailing
# comments, fsplit generates a file containing only comments and the
# compiler barfs on it.  Here's an abbreviation for deleting any such
# files generated, assuming two possible forms of the name generated:
# caveat naming routines!  Always use this after fsplit for safety...
RMEMPTY = rm -f ZZZ*.$(F) zzz*.$(F)

# modules to go in libccp4.a:
LIBTARGETS = ccplib fftlib maplib parser rwatom rwbrook modlib \
           symlib lcflib mtzlib diskio unix plot84lib \
           binsortint library plotsubs 

.PRECIOUS : $(srcdir)/library.c-dist $L # don't zap the library if a component fails

# probably only recognised by GNU make:
.PHONY : all clean install $(LIBTARGETS) ranlib realclean distclean \
         test help test-lib uninstall tags mosflm-stuff

all :  $L binsort $(MAYBEMOSFLM)

$L : $L(ccplib.o) $L(fftlib.o) $L(maplib.o) $L(parser.o) $L(rwatom.o) \
	  $L(rwbrook.o) $L(modlib.o) $L(symlib.o) $L(lcflib.o) \
	  $L(mtzlib.o) $L(diskio.o) $L(unix.o) \
	  $L(binsortint.o) $L(library.o) \
	  $L(plot84lib.o) $L(plotsubs.o)
# titan special:
	-(test -f /usr/lib/fortran/time.o && make '$L(time.o)') || true
	$(RANLIB) $@

test-lib : $(srcdir)/testlib.f $L(library.o) $L(unix.o) $L(ccplib.o) \
          $L(diskio.o)
	$(RANLIB) $L

# mosflm stuff, some of which we'd like to disown:
mosflm-stuff : $L(graflib.o) $L(chelp.o) $L(pack_c.o) $L(pack_f.o)

# explicit building of the real targets, sigh...
# include the pwd info for ease of symbolic debugging

$L(ccplib.o) : $(srcdir)/ccplib.f
	-rm -rf ccplib.dir; mkdir ccplib.dir
	echo '      SUBROUTINE CCPLIB' > ccplib.dir/ccplib.$F
	echo '      END' >> ccplib.dir/ccplib.$F
	cd ccplib.dir && fsplit $(srcdir)/ccplib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done \
          && $(AR) ../$L *.o
	rm -f ccplib.dir/*.o
ccplib : $L(ccplib.o)
	$(RANLIB) $L

$L(fftlib.o) : $(srcdir)/fftlib.f
	-rm -rf fftlib.dir; mkdir fftlib.dir
	echo '      SUBROUTINE FFTLIB' > fftlib.dir/fftlib.$F
	echo '      END' >> fftlib.dir/fftlib.$F
	cd fftlib.dir && fsplit $(srcdir)/fftlib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done \
          && $(AR) ../$L *.o
	rm -f fftlib.dir/*.o
fftlib : $L(fftlib.o)
	$(RANLIB) $L

$L(maplib.o) : $(srcdir)/maplib.f
	-rm -rf maplib.dir; mkdir maplib.dir
	echo '      SUBROUTINE MAPLIB' > maplib.dir/maplib.$F
	echo '      END' >> maplib.dir/maplib.$F
	cd maplib.dir && fsplit $(srcdir)/maplib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f maplib.dir/*.o
maplib : $L(maplib.o)
	$(RANLIB) $L

$L(parser.o) : $(srcdir)/parser.f
	-rm -rf parser.dir; mkdir parser.dir
	cd parser.dir && fsplit $(srcdir)/parser.f && $(RMEMPTY);
# `-' for convex, sigh
	-if test ! -f parser.dir/parser.$F; then \
	  echo '      SUBROUTINE PRSER' > parser.dir/parser.$F; \
	  echo '      END' >> parser.dir/parser.$F; \
	fi
	cd parser.dir && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f parser.dir/*.o
parser : $L(parser.o)
	$(RANLIB) $L

$L(rwbrook.o) : $(srcdir)/rwbrook.f
	-rm -rf rwbrook.dir; mkdir rwbrook.dir
	echo '      SUBROUTINE RWBROOK' > rwbrook.dir/rwbrook.$F
	echo '      END' >> rwbrook.dir/rwbrook.$F
	cd rwbrook.dir && fsplit $(srcdir)/rwbrook.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f rwbrook.dir/*.o
rwbrook : $L(rwbrook.o)
	$(RANLIB) $L


$L(rwatom.o) : $(srcdir)/rwatom.f
	-rm -rf rwatom.dir; mkdir rwatom.dir
	echo '      SUBROUTINE RWATOM' > rwatom.dir/rwatom.$F
	echo '      END' >> rwatom.dir/rwatom.$F
	cd rwatom.dir && fsplit $(srcdir)/rwatom.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f rwatom.dir/*.o
rwatom : $L(rwatom.o)
	$(RANLIB) $L

$L(modlib.o) : $(srcdir)/modlib.f
	-rm -rf modlib.dir; mkdir modlib.dir
	echo '      SUBROUTINE MODLIB' > modlib.dir/modlib.$F
	echo '      END' >> modlib.dir/modlib.$F
	cd modlib.dir && fsplit $(srcdir)/modlib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f modlib.dir/*.o
modlib : $L(modlib.o)
	$(RANLIB) $L

$L(symlib.o) : $(srcdir)/symlib.f
	-rm -rf symlib.dir; mkdir symlib.dir
	echo '      SUBROUTINE SYMLIB' > symlib.dir/symlib.$F
	echo '      END' >> symlib.dir/symlib.$F
	cd symlib.dir && fsplit $(srcdir)/symlib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f symlib.dir/*.o
symlib : $L(symlib.o)
	$(RANLIB) $L

$L(lcflib.o) : $(srcdir)/lcflib.f
	-rm -rf lcflib.dir; mkdir lcflib.dir
	echo '      SUBROUTINE LCFLIB' > lcflib.dir/lcflib.$F
	echo '      END' >> lcflib.dir/lcflib.$F
	cd lcflib.dir && fsplit $(srcdir)/lcflib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
	    $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f lcflib.dir/*.o
lcflib : $L(lcflib.o)
	$(RANLIB) $L

$L(mtzlib.o) : $(srcdir)/mtzlib.f
	-rm -rf mtzlib.dir; mkdir mtzlib.dir
	echo '      SUBROUTINE MTZLIB' > mtzlib.dir/mtzlib.$F
	echo '      END' >> mtzlib.dir/mtzlib.$F
	cd mtzlib.dir && fsplit $(srcdir)/mtzlib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f mtzlib.dir/*.o
mtzlib : $L(mtzlib.o)
	$(RANLIB) $L

$L(diskio.o) : $(srcdir)/diskio.f
	-rm -rf diskio.dir; mkdir diskio.dir
	echo '      SUBROUTINE DISKIO' > diskio.dir/diskio.$F
	echo '      END' >> diskio.dir/diskio.$F
	cd diskio.dir && fsplit $(srcdir)/diskio.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f diskio.dir/*.o
diskio : $L(diskio.o)

$L(plot84lib.o) : $(srcdir)/plot84lib.f
	-rm -rf plot84lib.dir; mkdir plot84lib.dir
	echo '      SUBROUTINE PLOT84LIB' > plot84lib.dir/plot84lib.$F
	echo '      END' >> plot84lib.dir/plot84lib.$F
	cd plot84lib.dir && fsplit $(srcdir)/plot84lib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f plot84lib.dir/*.o
plot84lib : $L(plot84lib.o)
	$(RANLIB) $L

$L(plotsubs.o) : $(srcdir)/plotsubs.f
	-rm -rf plotsubs.dir; mkdir plotsubs.dir
	echo '      SUBROUTINE PLOTSUBS' > plotsubs.dir/plotsubs.$F
	echo '      END' >> plotsubs.dir/plotsubs.$F
	cd plotsubs.dir && fsplit $(srcdir)/plotsubs.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f plotsubs.dir/*.o
plotsubs : $L(plotsubs.o)
	$(RANLIB) $L

$L(graflib.o) : $(srcdir)/graflib.f
	-rm -rf graflib.dir; mkdir graflib.dir
	echo '      SUBROUTINE GRAFLIB' > graflib.dir/graflib.$F
	echo '      END' >> graflib.dir/graflib.$F
	cd graflib.dir && fsplit $(srcdir)/graflib.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f graflib.dir/*.o
graflib : $L(graflib.o)
	$(RANLIB) $L

# C stuff: (these are kept as whole modules)

$L(library.o) : $(srcdir)/library.c
	$(CC) $(CFLAGS) -c $(srcdir)/library.c
	$(AR) $L library.o && rm library.o
library : $L(library.o)
	$(RANLIB) $L

# These next targets are only any use if you have the noweb system
# The following shouldn't run unless you're actually modifying
$(srcdir)/library.c : $(srcdir)/library.nw
# first save the distributed one in case of disasters
	test -f $@-dist || mv $@ $@-dist
	-notangle -L $? > $@ || mv $@-dist $@
library.tex: $(srcdir)/library.nw
	noweave -index -delay $? >library.tex
library.dvi: library.tex
	latex library
	latex library
	makeindex library
	latex library

$L(binsortint.o) : $(srcdir)/binsortint.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/binsortint.c
	$(AR) $L binsortint.o && rm binsortint.o
binsortint : $L(binsortint.o)
	$(RANLIB) $L

$L(chelp.o) : $(srcdir)/chelp.c
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/chelp.c
	$(AR) $L chelp.o && rm chelp.o
chelp : $L(chelp.o)
	$(RANLIB) $L

#
# specials
#

#  a program:
binsort : $(srcdir)/binsort.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -o $@ $(srcdir)/binsort.c
# for testing with src directory in path:
	-rm -f ../../src/binsort
	test -d ../../src && $(LNS) `pwd`/binsort ../../src/binsort

# the unix-specific bits need preprocessing for different unix variants
unix.f : $(srcdir)/unix.m4 gdummy.f
	$(M4) $(srcdir)/unix.m4 >unix.f
gdummy.f : $(srcdir)/gdummy.f
	-$(LNS)	$(srcdir)/gdummy.f .
$L(unix.o) : unix.f
	-rm -rf unix.dir; mkdir unix.dir
	echo '      SUBROUTINE UNIX' > unix.dir/unix.f
	echo '      END' >> unix.dir/unix.f
	cd unix.dir && fsplit ../unix.f >/dev/null && $(RMEMPTY) && \
          for i in `pwd`/*.$F; do \
            $(FC) -c $(FFLAGS) $$i; done\
          && $(AR) ../$L *.o
	rm -f unix.dir/*.o
unix : $L(unix.o)
	$(RANLIB) $L

#  The image (un)packing routines which are needed for mosflm and may be 
#  generally useful, but not built by default
$L(pack_c.o):	$(srcdir)/pack_c.c
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/pack_c.c
	$(AR) $L pack_c.o && rm pack_c.o
$L(pack_f.o):	$(srcdir)/pack_f.f
	$(FC) -c $(FFLAGS) $(srcdir)/pack_f.$(F) && $(AR) $(L) pack_f.o \
          && rm pack_f.o
pack:	$L(pack_c.o) $L(pack_f.o)
	$(RANLIB) $(L) 

# Apparently titan needs to link /usr/lib/fortran/time.o.  It seems
# easiest to stuff it in the library
$L(time.o) : /usr/lib/fortran/time.o
	$(AR) $(L) /usr/lib/fortran/time.o

# testbed for library.c and some other modules:
testlib : test-lib $(srcdir)/testlib.f
	$(FC) -o testlib $(FFLAGS) $(srcdir)/testlib.f $(LDFLAGS)

#
# standard targets
#

install : all
	$(INSTALL_PROGRAM) binsort $(bindir)
	$(INSTALL_DATA) $L $(libdir)/$L
	$(RANLIB) $(libdir)/$L

unintstall :
	-rm -f $(bindir)/binsort $(libdir)/$L

clean :
	-rm -f core *.o *~ *.dir/*.o testlib disc.dft a.out *.orig *.rej defs.m4
	-rm -rf tagdir

realclean : clean
	-rm -rf $L ../../src/binsort binsort *.dir TAGS

dist : realclean
	-rm -f Makefile

test : testlib
	./testlib -v 3 testenv foo

tags TAGS : unix.f
	etags ${srcdir}/*.[fch] #${srcdir}/unix.m4
#	sed -e -e 's|^\([a-zA-Z_]*.c\),|$(srcdir)/\1,|' \
# 		-e 's/unix.f/unix.m4/' tagdir/TAGS > TAGS
	rm -f unix.f

# Local Variables:
# mode:makefile
# End:
