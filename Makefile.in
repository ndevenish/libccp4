
# Makefile tail for CCP4 Library.  This will be modified by configure.

# $Header$

# Usage: make                 - to make the library in this directory
#        make <module>        - to make that particular module
#        make binsort         - for the binsort program in this directory
#        make install         - to copy the results into binary directory
#        make test            - to compile and run the library testbed

# This is horrible in the hope of being able to cater for all makes
# and still have the advantage of not re-making the library
# un-necessarily without sentinel files.  A combination of makes not
# understanding VPATH and not dealing with foo(bar) targets well and
# the fact that the Fortran sources are stored as .for means that we
# need to do everything explicitly -- ugh.  Note that we do assume
# that the make recognises a target foo.a(bar.o) as a library member.
# Life would be so much easier if we could rely on using GNU make; I
# wonder whether we should distribute it...

# The modules in the library are mostly individual Fortran routines
# and the results of compiling whole C source files.  We don't put
# whole fortran modules in as a monolithic .o file because that can
# make the linked programs larger and also causes problems (at least
# on Convex) with multiple symbol definitions where programs define a
# routine of a name already in the library and other routines from
# that module are called.  Thus most of the targets are built like
# this; for module foo:
#
# * rm any existing foo.dir and create a new one;
# * cd into foo.dir and fsplit the source file into it;
# * compile .o files from *.f;
# * establish a dummy `sentinel' file foo.o in the library.  This
#   seems perferable to me to leaving sentinel files around in the
#   source directory.  (The sentinel is made last to avoid problems if
#   the make is interrupted.)  My original tactic of using an empty
#   file doesn't work in AIX because it isn't in object format ;
# * ar *.o into ../libccp4.a;
# * rm *.o from foo.dir (we want to leave *.f there so you can do
#   symbolic debug, and also include the absolute path for this, but
#   see comments at definition of WD below.

# The following variables are expected to be set by configure:
# top_srcdir libdir bindir FC FFLAGS CC CFLAGS RANLIB LNS M4 F
# INSTALL_PROGRAM INSTALL_DATA MAYBEMOSFLM

SHELL       = /bin/sh
srcdir	    = $(top_srcdir)/lib/src
L           = libccp4.a#        convenient abbreviation only
LIB_DIR     = .

# This should, ideally, be set to "`pwd`/" to get the full path into
# the modules for symbolic debugging, but that tends to make lines too
# long for sh sometimes,  sigh.  Fixme: at least make this
# configurable -- it's probably possible to hack it so that if the
# command fails with pwd in there, make tries again recursively
# without it...
# WD          = `pwd`/
WD          =

# The following is for the benefit of Alliant, which is the only
# system I know where you can't use -L to specify the load path.
# (This works since make variables are defined in the environment in
# Alliant (GNU) make.)  We'd like to use $(LIB_DIR) instead of `.'
# here, but can't since that would require `:=' instead of `=' and
# confuse other makes.
LD_PATH = . /lib /usr/lib /usr/local/lib

# how to add a member to an archive (second and first args
# respectively); this might need to be set by configure:
AR          = ar r

# On some systems (Concentrix, for instance), for files with trailing
# comments, fsplit generates a file containing only comments and the
# compiler barfs on it.  Here's an abbreviation for deleting any such
# files generated, assuming two possible forms of the name generated:
# caveat naming routines!  Always use this after fsplit for safety...
RMEMPTY = rm -f ZZZ*.$(F) zzz*.$(F)

# modules to go in libccp4.a:
LIBTARGETS = ccplib fftlib maplib parser rwatom rwbrook modlib \
           symlib lcflib mtzlib diskio unix plot84lib \
           binsortint library plotsubs 

.PRECIOUS : $L                 # don't zap the library if a component fails

# probably only recognised by GNU make:
.PHONY : all clean install $(LIBTARGETS) ranlib realclean distclean \
         test help test-lib uninstall tags mosflm-stuff

all :  $L binsort $(MAYBEMOSFLM)

$L : $L(ccplib.o) $L(fftlib.o) $L(maplib.o) $L(parser.o) $L(rwatom.o) \
	  $L(rwbrook.o) $L(modlib.o) $L(symlib.o) $L(lcflib.o) \
	  $L(mtzlib.o) $L(diskio.o) $L(unix.o) \
	  $L(binsortint.o) $L(library.o) \
	  $L(plot84lib.o) $L(plotsubs.o)
	$(RANLIB) $@

test-lib : $(srcdir)/testlib.for $L(library.o) $L(unix.o) $L(ccplib.o) \
          $L(diskio.o)
	$(RANLIB) $L

# mosflm stuff, some of which we'd like to disown:
mosflm-stuff : $L(graflib.o) $L(chelp.o) $L(pack_c.o) $L(pack_f.o)

# explicit building of the real targets, sigh...
# include the pwd info for ease of symbolic debugging

$L(ccplib.o) : $(srcdir)/ccplib.for
	-rm -rf ccplib.dir; mkdir ccplib.dir
	echo '      SUBROUTINE CCPLIB' > ccplib.dir/ccplib.$F
	echo '      END' >> ccplib.dir/ccplib.$F
	cd ccplib.dir && fsplit $(srcdir)/ccplib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f ccplib.dir/*.o
ccplib : $L(ccplib.o)
	$(RANLIB) $L

$L(fftlib.o) : $(srcdir)/fftlib.for
	-rm -rf fftlib.dir; mkdir fftlib.dir
	echo '      SUBROUTINE FFTLIB' > fftlib.dir/fftlib.$F
	echo '      END' >> fftlib.dir/fftlib.$F
	cd fftlib.dir && fsplit $(srcdir)/fftlib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f fftlib.dir/*.o
fftlib : $L(fftlib.o)
	$(RANLIB) $L

$L(maplib.o) : $(srcdir)/maplib.for
	-rm -rf maplib.dir; mkdir maplib.dir
	echo '      SUBROUTINE MAPLIB' > maplib.dir/maplib.$F
	echo '      END' >> maplib.dir/maplib.$F
	cd maplib.dir && fsplit $(srcdir)/maplib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f maplib.dir/*.o
maplib : $L(maplib.o)
	$(RANLIB) $L

$L(parser.o) : $(srcdir)/parser.for
	-rm -rf parser.dir; mkdir parser.dir
	cd parser.dir && fsplit $(srcdir)/parser.for && $(RMEMPTY);
# `-' for convex, sigh
	-if test ! -f parser.dir/parser.$F; then \
	  echo '      SUBROUTINE PRSER' > parser.dir/parser.$F; \
	  echo '      END' >> parser.dir/parser.$F; \
	fi
	cd parser.dir && $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f parser.dir/*.o
parser : $L(parser.o)
	$(RANLIB) $L

$L(rwbrook.o) : $(srcdir)/rwbrook.for
	-rm -rf rwbrook.dir; mkdir rwbrook.dir
	echo '      SUBROUTINE RWBROOK' > rwbrook.dir/rwbrook.$F
	echo '      END' >> rwbrook.dir/rwbrook.$F
	cd rwbrook.dir && fsplit $(srcdir)/rwbrook.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f rwbrook.dir/*.o
rwbrook : $L(rwbrook.o)
	$(RANLIB) $L

$L(rwatom.o) : $(srcdir)/rwatom.for
	-rm -rf rwatom.dir; mkdir rwatom.dir
	echo '      SUBROUTINE RWATOM' > rwatom.dir/rwatom.$F
	echo '      END' >> rwatom.dir/rwatom.$F
	cd rwatom.dir && fsplit $(srcdir)/rwatom.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f rwatom.dir/*.o
rwatom : $L(rwatom.o)
	$(RANLIB) $L

$L(modlib.o) : $(srcdir)/modlib.for
	-rm -rf modlib.dir; mkdir modlib.dir
	echo '      SUBROUTINE MODLIB' > modlib.dir/modlib.$F
	echo '      END' >> modlib.dir/modlib.$F
	cd modlib.dir && fsplit $(srcdir)/modlib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f modlib.dir/*.o
modlib : $L(modlib.o)
	$(RANLIB) $L

$L(symlib.o) : $(srcdir)/symlib.for
	-rm -rf symlib.dir; mkdir symlib.dir
	echo '      SUBROUTINE SYMLIB' > symlib.dir/symlib.$F
	echo '      END' >> symlib.dir/symlib.$F
	cd symlib.dir && fsplit $(srcdir)/symlib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f symlib.dir/*.o
symlib : $L(symlib.o)
	$(RANLIB) $L

$L(lcflib.o) : $(srcdir)/lcflib.for
	-rm -rf lcflib.dir; mkdir lcflib.dir
	echo '      SUBROUTINE LCFLIB' > lcflib.dir/lcflib.$F
	echo '      END' >> lcflib.dir/lcflib.$F
	cd lcflib.dir && fsplit $(srcdir)/lcflib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f lcflib.dir/*.o
lcflib : $L(lcflib.o)
	$(RANLIB) $L

$L(mtzlib.o) : $(srcdir)/mtzlib.for
	-rm -rf mtzlib.dir; mkdir mtzlib.dir
	echo '      SUBROUTINE MTZLIB' > mtzlib.dir/mtzlib.$F
	echo '      END' >> mtzlib.dir/mtzlib.$F
	cd mtzlib.dir && fsplit $(srcdir)/mtzlib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f mtzlib.dir/*.o
mtzlib : $L(mtzlib.o)
	$(RANLIB) $L

$L(diskio.o) : $(srcdir)/diskio.for
	-rm -rf diskio.dir; mkdir diskio.dir
	echo '      SUBROUTINE DISKIO' > diskio.dir/diskio.$F
	echo '      END' >> diskio.dir/diskio.$F
	cd diskio.dir && fsplit $(srcdir)/diskio.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f diskio.dir/*.o
diskio : $L(diskio.o)

$L(plot84lib.o) : $(srcdir)/plot84lib.for
	-rm -rf plot84lib.dir; mkdir plot84lib.dir
	echo '      SUBROUTINE PLOT84LIB' > plot84lib.dir/plot84lib.$F
	echo '      END' >> plot84lib.dir/plot84lib.$F
	cd plot84lib.dir && fsplit $(srcdir)/plot84lib.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f plot84lib.dir/*.o
plot84lib : $L(plot84lib.o)
	$(RANLIB) $L

$L(plotsubs.o) : $(srcdir)/plotsubs.for
	-rm -rf plotsubs.dir; mkdir plotsubs.dir
	echo '      SUBROUTINE PLOTSUBS' > plotsubs.dir/plotsubs.$F
	echo '      END' >> plotsubs.dir/plotsubs.$F
	cd plotsubs.dir && fsplit $(srcdir)/plotsubs.for && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f plotsubs.dir/*.o
plotsubs : $L(plotsubs.o)
	$(RANLIB) $L

$L(graflib.o) : $(srcdir)/graflib.for
	-rm -rf graflib.dir; mkdir graflib.dir
	echo '      SUBROUTINE GRAFLIB' > graflib.dir/graflib.$F
	echo '      END' >> graflib.dir/graflib.$F
# split this into two because the list of sources is too long in HP-SUX 
	cd graflib.dir && fsplit $(srcdir)/graflib.for && $(RMEMPTY) && \
        $(FC) -c $(FFLAGS) $(WD)[gA-Pa-p]*.$F && $(AR) ../$L *.o && \
          $(FC) -c $(FFLAGS) $(WD)[Q-Zq-z]*.$F && $(AR) ../$L *.o
	rm -f graflib.dir/*.o
graflib : $L(graflib.o)
	$(RANLIB) $L

# C stuff: (these are kept as whole modules)

$L(library.o) : $(srcdir)/library.c
	$(CC) $(CFLAGS) -c $(srcdir)/library.c
	$(AR) $L library.o && rm library.o
library : $L(library.o)
	$(RANLIB) $L

$L(binsortint.o) : $(srcdir)/binsortint.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/binsortint.c
	$(AR) $L binsortint.o && rm binsortint.o
binsortint : $L(binsortint.o)
	$(RANLIB) $L

$L(chelp.o) : $(srcdir)/chelp.c
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/chelp.c
	$(AR) $L chelp.o && rm chelp.o
chelp : $L(chelp.o)
	$(RANLIB) $L

#
# specials
#

#  a program:
binsort : $(srcdir)/binsort.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -o $@ $(srcdir)/binsort.c
# for testing with src directory in path:
	-rm -f ../../src/binsort
	$(LNS) binsort ../../src/binsort

# the unix-specific bits need preprocessing for different unix variants
unix.$F : $(srcdir)/unix.m4 gdummy.$F
	$(M4) $(srcdir)/unix.m4 >unix.$F
gdummy.$F : $(srcdir)/gdummy.for
	-rm -rf gdummy.$F; $(LNS) $(srcdir)/gdummy.for gdummy.$F
$L(unix.o) : unix.$F gdummy.$F
	-rm -rf unix.dir; mkdir unix.dir
	echo '      SUBROUTINE UNIX' > unix.dir/unix.$F
	echo '      END' >> unix.dir/unix.$F
	cd unix.dir && fsplit ../unix.$F && $(RMEMPTY) && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f unix.dir/*.o
unix : $L(unix.o)
	$(RANLIB) $L

#  The image (un)packing routines which are needed for mosflm and may be 
#  generally useful, but not built by default
$L(pack_c.o):	$(srcdir)/pack_c.c
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/pack_c.c
	$(AR) $L pack_c.o && rm pack_c.o
$L(pack_f.o):	$(srcdir)/pack_f.for
	-rm -f pack_f.$(F) 2>/dev/null
	$(LNS) $(srcdir)/pack_f.for pack_f.$(F)
	$(FC) -c $(FFLAGS) $(WD)pack_f.$(F) && $(AR) $(L) pack_f.o \
          && rm pack_f.o
pack:	$L(pack_c.o) $L(pack_f.o)
	$(RANLIB) $(L) 

# testbed for library.c and some other modules:
testlib : test-lib $(srcdir)/testlib.for
	-rm -f testlib.$F; $(LNS) $(srcdir)/testlib.for testlib.$F
	$(FC) -o testlib $(FFLAGS) testlib.$F $(LDFLAGS)

#
# standard targets
#

install : all
	$(INSTALL_PROGRAM) binsort $(bindir)
	$(INSTALL_DATA) $L $(libdir)/$L
	$(RANLIB) $(libdir)/$L

unintstall :
	-rm -f $(bindir)/binsort $(libdir)/$L

clean :
	-rm -f core *.o *~ *.dir/*.o testlib disc.dft a.out *.orig *.rej
	-rm -rf tagdir

realclean : clean
	-rm -rf $L *.$(F) ../../src/binsort binsort *.dir TAGS

dist : realclean
	-rm -f Makefile

test : testlib
	./testlib -v 3 testenv foo

tags :
	-rm -rf tagdir; mkdir tagdir
	ln -s $(srcdir)/*.c tagdir
	for i in $(srcdir)/*.for; do \
 		ln -s $$i tagdir/`basename $$i .for`.f; done
	ln -s $(srcdir)/unix.m4 tagdir/unix.f
	cd tagdir; etags *.[fc]
	sed -e 's|^\([a-zA-Z_]*\).f,|$(srcdir)/\1.for,|' \
 		-e 's|^\([a-zA-Z_]*.c\),|$(srcdir)/\1,|' \
 		-e 's/unix.for/unix.m4/' tagdir/TAGS > TAGS
	rm -rf tagdir
