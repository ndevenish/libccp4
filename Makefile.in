
# Makefile tail for CCP4 Library.  This will be modified by configure.

# $Header$

# Usage: make                 - to make the library in this directory
#        make <module>        - to make that particular module
#        make binsort         - for the binsort program in this directory
#        make install         - to copy the results into binary directory
#        make test            - to compile and run the library testbed

# This is horrible in the hope of being able to cater for all makes
# and still have the advantage of not re-making the library
# un-necessarily without sentinel files.  A combination of makes not
# understanding VPATH and not dealing with foo(bar) targets well and
# the fact that the Fortran sources are stored as .for means that we
# need to do everything explicitly -- ugh.  Note that we do assume
# that the make recognises a target foo.a(bar.o) as a library member.
# Life would be so much easier if we could rely on using GNU make; I
# wonder whether we should distribute it...

# The modules in the library are mostly individual Fortran routines
# and the results of compiling whole C source files.  We don't put
# whole fortran modules in as a monolithic .o file because that can
# make the linked programs larger and also causes problems (at least
# on Convex) with multiple symbol definitions where programs define a
# routine of a name already in the library and other routines from
# that module are called.  Thus most of the targets are built like
# this; for module foo:
# * rm any existing foo.dir and create a new one
# * cd into foo.dir and fsplit the source file into it
# * compile .o files from *.f
# * make an empty `sentinel' file foo.o if there isn't already a
#   routine foo in the library
# * ar *.o into ../libccp4.a
# * rm *.o from foo.dir (leave *.f there so you can do symbolic debug,
#   although you then have to get the path right)

# The following variables are expected to be set by configure:
# top_srcdir libdir bindir FC FFLAGS CC CFLAGS RANLIB LNS M4 F

SHELL       = /bin/sh
incdir      = $(top_srcdir)/include
srcdir	    = $(top_srcdir)/lib/src
L           = libccp4.a#        convenient abbreviation only

INSTALL_BIN = cp# fixme: should be set by configure
INSTALL_DATA = cp# fixme: should be set by configure

# how to add a member to an archive (second and first args
# respectively); this might need to be set by configure:
AR          = ar r

# modules to go in libccp4.a:
LIBTARGETS = ccplib fftlib maplib parser rwatom rwbrook modlib \
           symlib lcflib mtzlib diskio unix frodo_maplib plot84lib graflib \
           graphics binsortint library ucurse hlplib gdummy

all :  $L binsort

.PRECIOUS : $L $(libdir)/$L     # don't zap the library if a component fails

# probably only recognised by GNU make:
.PHONY : all clean install $(LIBTARGETS) ranlib realclean distclean \
         test help

$L : $L(ccplib.o) $L(fftlib.o) $L(maplib.o) $L(parser.o) $L(rwatom.o) \
	  $L(rwbrook.o) $L(modlib.o) $L(mthlib.o) $L(symlib.o) $L(lcflib.o) \
	  $L(mtzlib.o) $L(diskio.o) $L(unix.o) $L(frodo_maplib.o) \
	  $L(binsortint.o) $L(library.o) $L(ucurse.o) $L(hlplib.o) \
	  $L(plot84lib.o) $L(graflib.o) $L(graphics.o) $L(gdummy.o)
	$(RANLIB) $@

ranlib: ; $(RANLIB) $L

$(LIBTARGETS) : ; $(MAKE) $(MFLAGS) "$L($@.o)"

# explicit building of the real targets, sigh...

$L(ccplib.o) : $(srcdir)/ccplib.for
	-rm -rf ccplib.dir; mkdir ccplib.dir
	cd ccplib.dir; fsplit $(srcdir)/ccplib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch ccplib.o; \
	  $(AR) ../$L *.o
	rm -f ccplib.dir/*.o

$L(fftlib.o) : $(srcdir)/fftlib.for
	-rm -rf fftlib.dir; mkdir fftlib.dir
	cd fftlib.dir; fsplit $(srcdir)/fftlib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch fftlib.o; \
	  $(AR) ../$L *.o
	rm -f fftlib.dir/*.o

$L(maplib.o) : $(srcdir)/maplib.for
	-rm -rf maplib.dir; mkdir maplib.dir
	cd maplib.dir; fsplit $(srcdir)/maplib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch maplib.o; \
	  $(AR) ../$L *.o
	rm -f maplib.dir/*.o

$L(parser.o) : $(srcdir)/parser.for
	-rm -rf parser.dir; mkdir parser.dir
	cd parser.dir; fsplit $(srcdir)/parser.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch parser.o; \
	  $(AR) ../$L *.o
	rm -f parser.dir/*.o

$L(rwbrook.o) : $(srcdir)/rwbrook.for
	-rm -rf rwbrook.dir; mkdir rwbrook.dir
	cd rwbrook.dir; fsplit $(srcdir)/rwbrook.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch rwbrook.o; \
	  $(AR) ../$L *.o
	rm -f rwbrook.dir/*.o

$L(rwatom.o) : $(srcdir)/rwatom.for
	-rm -rf rwatom.dir; mkdir rwatom.dir
	cd rwatom.dir; fsplit $(srcdir)/rwatom.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch rwatom.o; \
	  $(AR) ../$L *.o
	rm -f rwatom.dir/*.o

$L(modlib.o) : $(srcdir)/modlib.for
	-rm -rf modlib.dir; mkdir modlib.dir
	cd modlib.dir; fsplit $(srcdir)/modlib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch modlib.o; \
	  $(AR) ../$L *.o
	rm -f modlib.dir/*.o

$L(mthlib.o) : $(srcdir)/mthlib.for
	-rm -rf mthlib.dir; mkdir mthlib.dir
	cd mthlib.dir; fsplit $(srcdir)/mthlib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch mthlib.o; \
	  $(AR) ../$L *.o
	rm -f mthlib.dir/*.o

$L(symlib.o) : $(srcdir)/symlib.for
	-rm -rf symlib.dir; mkdir symlib.dir
	cd symlib.dir; fsplit $(srcdir)/symlib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch symlib.o; \
	  $(AR) ../$L *.o
	rm -f symlib.dir/*.o

$L(lcflib.o) : $(srcdir)/lcflib.for
	-rm -rf lcflib.dir; mkdir lcflib.dir
	cd lcflib.dir; fsplit $(srcdir)/lcflib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch lcflib.o; \
	  $(AR) ../$L *.o
	rm -f lcflib.dir/*.o

$L(mtzlib.o) : $(srcdir)/mtzlib.for
	-rm -rf mtzlib.dir; mkdir mtzlib.dir
	cd mtzlib.dir; fsplit $(srcdir)/mtzlib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch mtzlib.o; \
	  $(AR) ../$L *.o
	rm -f mtzlib.dir/*.o

$L(diskio.o) : $(srcdir)/diskio.for
	-rm -rf diskio.dir; mkdir diskio.dir
	cd diskio.dir; fsplit $(srcdir)/diskio.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch diskio.o; \
	  $(AR) ../$L *.o
	rm -f diskio.dir/*.o

$L(hlplib.o) : $(srcdir)/hlplib.for
	-rm -rf hlplib.dir; mkdir hlplib.dir
	cd hlplib.dir; fsplit $(srcdir)/hlplib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch hlplib.o; \
	  $(AR) ../$L *.o
	rm -f hlplib.dir/*.o

# fixme: change >14 characters name!
$L(frodo_maplib.o) : $(srcdir)/frodo_maplib.for
	-rm -rf frodo_maplib.dir; mkdir frodo_maplib.dir
	cd frodo_maplib.dir; fsplit $(srcdir)/frodo_maplib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch frodo_maplib.o; \
	  $(AR) ../$L *.o
	rm -f frodo_maplib.dir/*.o

$L(plot84lib.o) : $(srcdir)/plot84lib.for
	-rm -rf plot84lib.dir; mkdir plot84lib.dir
	cd plot84lib.dir; fsplit $(srcdir)/plot84lib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch plot84lib.o; \
	  $(AR) ../$L *.o
	rm -f plot84lib.dir/*.o

$L(graflib.o) : $(srcdir)/graflib.for
	-rm -rf graflib.dir; mkdir graflib.dir
	cd graflib.dir; fsplit $(srcdir)/graflib.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch graflib.o; \
	  $(AR) ../$L *.o
	rm -f graflib.dir/*.o

$L(graphics.o) : $(srcdir)/graphics.for
	-rm -rf graphics.dir; mkdir graphics.dir
	cd graphics.dir; fsplit $(srcdir)/graphics.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch graphics.o; \
	  $(AR) ../$L *.o
	rm -f graphics.dir/*.o

$L(gdummy.o) : $(srcdir)/gdummy.for
	-rm -rf gdummy.dir; mkdir gdummy.dir
	cd gdummy.dir; fsplit $(srcdir)/gdummy.for; \
	  $(FC) -c $(FFLAGS) *.$F; touch gdummy.o; \
	  $(AR) ../$L *.o
	rm -f gdummy.dir/*.o

# C stuff: (these are kept as whole modules)

$L(library.o) : $(srcdir)/library.c $(incdir)/machine.h \
   $(incdir)/dfconvert.h  $(incdir)/diconvert.h
	$(CC) $(CFLAGS) -I$(incdir) -c $(srcdir)/library.c
	$(AR) $L library.o; rm library.o

$L(binsortint.o) : $(srcdir)/binsortint.c $(incdir)/binsort.h
	$(CC) $(CFLAGS) -I$(incdir) -c $(srcdir)/binsortint.c
	$(AR) $L binsortint.o; rm binsortint.o

$L(ucurse.o) : $(srcdir)/ucurse.c
	$(CC) $(CFLAGS) -c $(srcdir)/ucurse.c
	$(AR) $L ucurse.o; rm ucurse.o

#
# specials
#

#  a program:
binsort : $(srcdir)/binsort.c $(incdir)/binsort.h
	$(CC) $(CFLAGS) -I$(incdir) -o $@ $(srcdir)/binsort.c
# for testing with src directory in path:
	-rm -f ../../src/binsort
	$(LNS) binsort ../../src/binsort

# the unix-specific bits need preprocessing for different unix variants
$L(unix.o) : $(srcdir)/unix.m4
	$(M4) $(srcdir)/unix.m4 >unix.$F
	-rm -rf unix.dir; mkdir unix.dir
	cd unix.dir; fsplit ../unix.$F; \
	  $(FC) -c $(FFLAGS) *.$F; touch unix.o ;\
	  $(AR) ../$L *.o
	rm -f unix.dir/*.o

# testbed for library.c:
testlib : $(srcdir)/testlib.for $L(library.o) $L(unix.o) $L(ccplib.o) \
          $L(diskio.o) ranlib
	-rm -f testlib.$F; $(LNS) $(srcdir)/testlib.for testlib.$F
	$(FC) -o testlib $(FFLAGS) testlib.$F $L

#
# standard targets
#

install :
	$(INSTALL_BIN) binsort $(bindir)
	$(INSTALL_DATA) $L $(libdir)/$L

clean :
	-rm -f core *.o *~ *.dir/*.o testlib disc.dft a.out

realclean: clean
	-rm -rf $L *.f *.c ../../src/binsort *.dir

dist: realclean
	-rm -f Makefile

test: testlib
	./testlib -v 3 testenv foo diskio disc.dft
