
# Makefile tail for CCP4 Library.  This will be modified by configure.

# $Header$

# Usage: make                 - to make the library in this directory
#        make <module>        - to make that particular module
#        make binsort         - for the binsort program in this directory
#        make install         - to copy the results into binary directory
#        make test            - to compile and run the library testbed

# This is horrible in the hope of being able to cater for all makes
# and still have the advantage of not re-making the library
# un-necessarily without sentinel files.  A combination of makes not
# understanding VPATH and not dealing with foo(bar) targets well and
# the fact that the Fortran sources are stored as .for means that we
# need to do everything explicitly -- ugh.  Note that we do assume
# that the make recognises a target foo.a(bar.o) as a library member.
# Life would be so much easier if we could rely on using GNU make; I
# wonder whether we should distribute it...

# The modules in the library are mostly individual Fortran routines
# and the results of compiling whole C source files.  We don't put
# whole fortran modules in as a monolithic .o file because that can
# make the linked programs larger and also causes problems (at least
# on Convex) with multiple symbol definitions where programs define a
# routine of a name already in the library and other routines from
# that module are called.  Thus most of the targets are built like
# this; for module foo:
#
# * rm any existing foo.dir and create a new one;
# * cd into foo.dir and fsplit the source file into it;
# * compile .o files from *.f;
# * establish a dummy `sentinel' file foo.o in the library.  This
#   seems perferable to me to leaving sentinel files around in the
#   source directory.  (The sentinel is made last to avoid problems if
#   the make is interrupted.)  My original tactic of using an empty
#   file doesn't work in AIX because it isn't in object format ;
# * ar *.o into ../libccp4.a;
# * rm *.o from foo.dir (we want to leave *.f there so you can do
#   symbolic debug, and also include the absolute path for this, but
#   see comments at definition of WD below.

# The following variables are expected to be set by configure:
# top_srcdir libdir bindir FC FFLAGS CC CFLAGS RANLIB LNS M4 F
# INSTALL_PROGRAM INSTALL_DATA

SHELL       = /bin/sh
srcdir	    = $(top_srcdir)/lib/src
L           = libccp4.a#        convenient abbreviation only
LIB_DIR     = .

# This should, ideally, be set to "`pwd`/" to get the full path into
# the modules for symbolic debugging, but that tends to make lines too
# long for sh sometimes,  sigh.  Fixme: at least make this
# configurable -- it's probably possible to hack it so that if the
# command fails with pwd in there, make tries again recursively
# without it...
# WD          = `pwd`/
WD          =

# The following is for the benefit of Alliant, which is the only
# system I know where you can't use -L to specify the load path.
# (This works since make variables are defined in the environment in
# Alliant (GNU) make.)  We'd like to use $(LIB_DIR) instead of `.'
# here, but can't since that would require `:=' instead of `=' and
# confuse other makes.
LD_PATH = . /lib /usr/lib /usr/local/lib

# how to add a member to an archive (second and first args
# respectively); this might need to be set by configure:
AR          = ar r

# modules to go in libccp4.a:
LIBTARGETS = ccplib fftlib maplib parser rwatom rwbrook modlib \
           symlib lcflib mtzlib diskio unix frodo_maplib plot84lib graflib \
           binsortint library ucurse hlplib gdummy

all :  $L binsort

.PRECIOUS : $L                 # don't zap the library if a component fails

# probably only recognised by GNU make:
.PHONY : all clean install $(LIBTARGETS) ranlib realclean distclean \
         test help

$L : $L(ccplib.o) $L(fftlib.o) $L(maplib.o) $L(parser.o) $L(rwatom.o) \
	  $L(rwbrook.o) $L(modlib.o) $L(symlib.o) $L(lcflib.o) \
	  $L(mtzlib.o) $L(diskio.o) $L(unix.o) $L(frodo_maplib.o) \
	  $L(binsortint.o) $L(library.o) $L(ucurse.o) $L(hlplib.o) \
	  $L(plot84lib.o) $L(graflib.o) $L(gdummy.o)
	$(RANLIB) $@

test-lib : $(srcdir)/testlib.for $L(library.o) $L(unix.o) $L(ccplib.o) \
          $L(diskio.o)
	$(RANLIB) $L

# explicit building of the real targets, sigh...
# include the pwd info for ease of symbolic debugging

$L(ccplib.o) : $(srcdir)/ccplib.for
	-rm -rf ccplib.dir; mkdir ccplib.dir
	echo '      SUBROUTINE CCPLIB' > ccplib.dir/ccplib.$F
	echo '      END' >> ccplib.dir/ccplib.$F
	cd ccplib.dir && fsplit $(srcdir)/ccplib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f ccplib.dir/*.o
ccplib : $L(ccplib.o)
	$(RANLIB) $L

$L(fftlib.o) : $(srcdir)/fftlib.for
	-rm -rf fftlib.dir; mkdir fftlib.dir
	echo '      SUBROUTINE FFTLIB' > fftlib.dir/fftlib.$F
	echo '      END' >> fftlib.dir/fftlib.$F
	cd fftlib.dir && fsplit $(srcdir)/fftlib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f fftlib.dir/*.o
fftlib : $L(fftlib.o)
	$(RANLIB) $L

$L(maplib.o) : $(srcdir)/maplib.for
	-rm -rf maplib.dir; mkdir maplib.dir
	echo '      SUBROUTINE MAPLIB' > maplib.dir/maplib.$F
	echo '      END' >> maplib.dir/maplib.$F
	cd maplib.dir && fsplit $(srcdir)/maplib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f maplib.dir/*.o
maplib : $L(maplib.o)
	$(RANLIB) $L

$L(parser.o) : $(srcdir)/parser.for
	-rm -rf parser.dir; mkdir parser.dir
	cd parser.dir && fsplit $(srcdir)/parser.for;
# `-' for convex, sigh
	-if test ! -f parser.dir/parser.$F; then \
	  echo '      SUBROUTINE PRSER' > parser.dir/parser.$F; \
	  echo '      END' >> parser.dir/parser.$F; \
	fi
	cd parser.dir && $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f parser.dir/*.o
parser : $L(parser.o)
	$(RANLIB) $L

$L(rwbrook.o) : $(srcdir)/rwbrook.for
	-rm -rf rwbrook.dir; mkdir rwbrook.dir
	echo '      SUBROUTINE RWBROOK' > rwbrook.dir/rwbrook.$F
	echo '      END' >> rwbrook.dir/rwbrook.$F
	cd rwbrook.dir && fsplit $(srcdir)/rwbrook.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f rwbrook.dir/*.o
rwbrook : $L(rwbrook.o)
	$(RANLIB) $L

$L(rwatom.o) : $(srcdir)/rwatom.for
	-rm -rf rwatom.dir; mkdir rwatom.dir
	echo '      SUBROUTINE RWATOM' > rwatom.dir/rwatom.$F
	echo '      END' >> rwatom.dir/rwatom.$F
	cd rwatom.dir && fsplit $(srcdir)/rwatom.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f rwatom.dir/*.o
rwatom : $L(rwatom.o)
	$(RANLIB) $L

$L(modlib.o) : $(srcdir)/modlib.for
	-rm -rf modlib.dir; mkdir modlib.dir
	echo '      SUBROUTINE MODLIB' > modlib.dir/modlib.$F
	echo '      END' >> modlib.dir/modlib.$F
	cd modlib.dir && fsplit $(srcdir)/modlib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f modlib.dir/*.o
modlib : $L(modlib.o)
	$(RANLIB) $L

$L(mthlib.o) : $(srcdir)/mthlib.for
	-rm -rf mthlib.dir; mkdir mthlib.dir
	echo '      SUBROUTINE MTHLIB' > mthlib.dir/mthlib.$F
	echo '      END' >> mthlib.dir/mthlib.$F
	cd mthlib.dir && fsplit $(srcdir)/mthlib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f mthlib.dir/*.o
mthlib : $L(mthlib.o)
	$(RANLIB) $L

$L(symlib.o) : $(srcdir)/symlib.for
	-rm -rf symlib.dir; mkdir symlib.dir
	echo '      SUBROUTINE SYMLIB' > symlib.dir/symlib.$F
	echo '      END' >> symlib.dir/symlib.$F
	cd symlib.dir && fsplit $(srcdir)/symlib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f symlib.dir/*.o
symlib : $L(symlib.o)
	$(RANLIB) $L

$L(lcflib.o) : $(srcdir)/lcflib.for
	-rm -rf lcflib.dir; mkdir lcflib.dir
	echo '      SUBROUTINE LCFLIB' > lcflib.dir/lcflib.$F
	echo '      END' >> lcflib.dir/lcflib.$F
	cd lcflib.dir && fsplit $(srcdir)/lcflib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f lcflib.dir/*.o
lcflib : $L(lcflib.o)
	$(RANLIB) $L

$L(mtzlib.o) : $(srcdir)/mtzlib.for
	-rm -rf mtzlib.dir; mkdir mtzlib.dir
	echo '      SUBROUTINE MTZLIB' > mtzlib.dir/mtzlib.$F
	echo '      END' >> mtzlib.dir/mtzlib.$F
	cd mtzlib.dir && fsplit $(srcdir)/mtzlib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f mtzlib.dir/*.o
mtzlib : $L(mtzlib.o)
	$(RANLIB) $L

$L(diskio.o) : $(srcdir)/diskio.for
	-rm -rf diskio.dir; mkdir diskio.dir
	echo '      SUBROUTINE DISKIO' > diskio.dir/diskio.$F
	echo '      END' >> diskio.dir/diskio.$F
	cd diskio.dir && fsplit $(srcdir)/diskio.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f diskio.dir/*.o
diskio : $L(diskio.o)

$L(hlplib.o) : $(srcdir)/hlplib.for
	-rm -rf hlplib.dir; mkdir hlplib.dir
	echo '      SUBROUTINE HLPLIB' > hlplib.dir/hlplib.$F
	echo '      END' >> hlplib.dir/hlplib.$F
	cd hlplib.dir && fsplit $(srcdir)/hlplib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f hlplib.dir/*.o
hlplib : $L(hlplib.o)
	$(RANLIB) $L

# fixme: change >14 characters name!
$L(frodo_maplib.o) : $(srcdir)/frodo_maplib.for
	-rm -rf frodo_maplib.dir; mkdir frodo_maplib.dir
	echo '      SUBROUTINE frodo_MAPLIB' > frodo_maplib.dir/frodo_maplib.$F
	echo '      END' >> frodo_maplib.dir/frodo_maplib.$F
	cd frodo_maplib.dir && fsplit $(srcdir)/frodo_maplib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f frodo_maplib.dir/*.o
frodo_maplib : $L(frodo_maplib.o)
	$(RANLIB) $L

$L(plot84lib.o) : $(srcdir)/plot84lib.for
	-rm -rf plot84lib.dir; mkdir plot84lib.dir
	echo '      SUBROUTINE PLOT84LIB' > plot84lib.dir/plot84lib.$F
	echo '      END' >> plot84lib.dir/plot84lib.$F
	cd plot84lib.dir && fsplit $(srcdir)/plot84lib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f plot84lib.dir/*.o
plot84lib : $L(plot84lib.o)
	$(RANLIB) $L

$L(graflib.o) : $(srcdir)/graflib.for
	-rm -rf graflib.dir; mkdir graflib.dir
	echo '      SUBROUTINE GRAFLIB' > graflib.dir/graflib.$F
	echo '      END' >> graflib.dir/graflib.$F
	cd graflib.dir && fsplit $(srcdir)/graflib.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f graflib.dir/*.o
graflib : $L(graflib.o)
	$(RANLIB) $L

$L(gdummy.o) : $(srcdir)/gdummy.for
	-rm -rf gdummy.dir; mkdir gdummy.dir
	cd gdummy.dir && fsplit $(srcdir)/gdummy.for && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F  && \
	  $(AR) ../$L *.o
	rm -f gdummy.dir/*.o
gdummy : $L(gdummy.o)
	$(RANLIB) $L

# C stuff: (these are kept as whole modules)

$L(library.o) : $(srcdir)/library.c $(srcdir)/machine.h $(srcdir)/dfconvert.h \
                $(srcdir)/diconvert.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/library.c
	$(AR) $L library.o && rm library.o
library : $L(library.o)
	$(RANLIB) $L

$L(binsortint.o) : $(srcdir)/binsortint.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/binsortint.c
	$(AR) $L binsortint.o && rm binsortint.o
binsortint : $L(binsortint.o)
	$(RANLIB) $L

$L(ucurse.o) : $(srcdir)/ucurse.c
	$(CC) $(CFLAGS) -I$(srcdir) -c $(srcdir)/ucurse.c
	$(AR) $L ucurse.o && rm ucurse.o
ucurse : $L(ucurse.o)
	$(RANLIB) $L

#
# specials
#

#  a program:
binsort : $(srcdir)/binsort.c $(srcdir)/binsort.h
	$(CC) $(CFLAGS) -I$(srcdir) -o $@ $(srcdir)/binsort.c
# for testing with src directory in path:
	-rm -f ../../src/binsort
	$(LNS) binsort ../../src/binsort

# the unix-specific bits need preprocessing for different unix variants
$L(unix.o) : $(srcdir)/unix.m4
	$(M4) $(srcdir)/unix.m4 >unix.$F
	-rm -rf unix.dir; mkdir unix.dir
	echo '      SUBROUTINE UNIX' > unix.dir/unix.$F
	echo '      END' >> unix.dir/unix.$F
	cd unix.dir && fsplit ../unix.$F && \
	  $(FC) -c $(FFLAGS) $(WD)*.$F && $(AR) ../$L *.o
	rm -f unix.dir/*.o
unix : $L(unix.o)
	$(RANLIB) $L

# testbed for library.c and some other modules:
testlib : test-lib
	-rm -f testlib.$F; $(LNS) $(srcdir)/testlib.for testlib.$F
	$(FC) -o testlib $(FFLAGS) testlib.$F $(LDFLAGS)

#
# standard targets
#

install :
	$(INSTALL_PROGRAM) binsort $(bindir)
	$(INSTALL_DATA) $L $(libdir)/$L

unintstall :
	-rm -f $(bindir)/binsort $(libdir)/$L

clean :
	-rm -f core *.o *~ *.dir/*.o testlib disc.dft a.out

realclean : clean
	-rm -rf $L *.$(F) ../../src/binsort binsort *.dir

dist : realclean
	-rm -f Makefile

test : testlib
	./testlib -v 3 testenv foo diskio disc.dft
