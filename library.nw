% -*-c-*-
% This is a literate program meant to be used as input to the `noweb'
% tools.  To produce the C file from it, use `notangle'; to produce
% the LaTeX documentation, use `noweave -n -x'.  You can also get an
% index using makindex.

% Copyright SERC Daresbury Laboratory 1992, 1993
% This is a CCP4 `part (i)' file for the purposes of copyright.  
% See the CCP4 distribution conditions for explanation.

\documentstyle[noweb,makeidx,times]{article}

\newcommand{\ac}[1]{{\rm\normalshape\sc #1}}   % acronym
\newcommand{\meta}[1]{\mbox{$\langle$\rm\sl #1\/$\rangle$}}
\newcommand{\ft}{\ac{fortran}}
\newcommand{\idx}[1]{#1\index{#1}}
\newcommand{\fixme}[1]{\index{Fixme!}[{\bf Fixme!:} #1.]}

\title{C library routines}\date{}\author{}

\makeindex

\begin{document}

\maketitle

\noindent
This file contains the lowest level routines for the CCP4 Program
Suite, mainly for i/o (as required by the {\tt diskio} routines) and
bit-twiddling.
\bigskip

\tableofcontents

\subsection*{List of chunks}
\chunklist

@ \section{Summary}

The following routines are defined:
\bigskip

\noindent
\begin{tabular}{ll}

Routine and  arguments &                      Purpose \\
\hline
[[ustenv(string, result)]]         & set an environment variable  \\
[[copen(iunit,filnam,istat)]]      & open random access file using [[fopen]] \\
[[qclose(iunit)]]                  & shut random access file using [[fclose]] \\
[[qmode(iunit,mode,nmcitm)]]       & change size of item in file ops. \\
[[qread(iunit,array,nitems,ier)]]  & [[fread]] from random access file \\
[[qwrite(iunit,array,nitems)]]     & [[fwrite]] to random access file \\
[[qseek(iunit,irec,iel,lrecl)]]    & [[fseek]] within random access file \\
[[qback(iunit,lrecl)]]             & backspace within random access file \\
[[qskip(iunit,lrecl)]]             & skip forward within random access file \\
[[cqinq(iunit,lfilnm,filnam,length)]] & inquire file status on the given stream \\
[[qlocate(iunit,locate)]]          & current position within random access file \\
[[qtype(istamp)]]                  & returns machine `\idx{type stamp}'
\end{tabular}


@ \section{Code}

These are the components of the code.  The \LA{}guarded code\RA{} is
executed when we've identified the platform.

<<*>>=
/* This was a literate program.  library.nw is the original source,
   from which library.c was generated by `notangle' and from which
   printable LaTeX can be produced by `noweave' if you have those
   tools. */
<<identifying the platform>>
<<guarded code>>

@ \section{Identifying the platform}

There are several platform dependencies in the code which we need to
get right:
\begin{description}
\item[Fortran/C conventions] The calling conventions for C from
  \ft{} vary from compiler to compiler;
\item[Header files etc.] We can't assume everything has \ac{ansi} C
  or \ac{posix} libraries;
\item[Real number format] for the `portable' binary i/o;
\item[Special things] The [[putenv]]/[[setenv]] call isn't defined in
  the current standards.
\end{description}

Each type of system we know about should cause [[KNOWN_MACHINE]] to be
defined and also define \verb+CALL_LIKE_+\meta{something} to be
defined.  Thus if you know system \meta{foo} has a \ft{}
calling convention like the native Sun compiler uses, define
[[CALL_LIKE_SUN]] and you won't need to examine the definitions of the
interface functions below.  Further tests on the system type may be
necessary e.g., to get the include files right.

\subsection{Assumptions}

Note that it's assumed below that a \ft{} [[INTEGER]]
corresponds to a C [[int]] and a \ft{} [[REAL]] corresponds to
a C [[float]].

Also, the identity of certain \idx{calling conventions} is only
guaranteed if the routines have only a single \ft{} 
\index{CHARACTER variables@{\tt CHARACTER} variables}
[[CHARACTER]]-type argument since sometimes the length of each such
argument is given after it in the parameter list and sometimes they
are all collected at the end of the list.

\subsection{Platform identification}

Apart from the possibility of using the \idx{Netlib} {\tt
  f2c}\index{f2c@{\tt f2c}} compiler we currently assume that each
system uses the vendor-supplied \ft{} compiler\index{FORTRAN
  compiler@\ft{} compiler}.\index{platforms}

{\tt f2c} support is currently not available because of the use of
{\tt BYTE} in {\tt ccplib} if nothing else.  Its calling convention is
like \idx{Sun} only for a {\em single\/} [[CHARACTER]] variable in the
parameter list!

<<identifying the platform>>=
#if F2C
/* #  define KNOWN_MACHINE */
#  define CALL_LIKE_SUN 1
@ This is for \idx{IBM} Unix systems---\idx{RS/6000} models, at least.
The compiler can append \verb+_+ to external names, but we assume the
default where this doesn't happen.  See {\tt configure} for the
enforcement of this.
<<identifying the platform>>=
#else
#if defined (_AIX)
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
@ This is for \idx{Alliant} \idx{FX28xx}, at least, e.g.\ the FX2800 at LMB\@.
<<identifying the platform>>=
#if defined (alliant)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
@ The \idx{Ardent} \idx{Stardent}/\idx{Titan} support probably doesn't
work at present.
<<identifying the platform>>=
#if defined (ardent) || defined (titan)
#  ifndef stardent
#    define stardent
#  endif
#endif
#if defined (stardent)
#  define KNOWN_MACHINE
#  define CALL_LIKE_STARDENT 1
#endif
@ 
There seem to be two possible ways of identifying a \idx{Convex}
(`C' series, at least) system.  [[__convexc__]] is documented in OS10
but [[__convex__]] seems to be there as well (and was probably
documented in OS8).
<<identifying the platform>>=
#if defined (__convex__) || defined (__convexc__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
@ The \idx{Evans and Sutherland} \idx{ESV1} workstation can operate in the
\idx{BSD} or \idx{SYSV} universes.  It doesn't seem to be properly
\index{POSIX@\ac{posix}}\ac{posix}- or \ac{ansi}
C-compliant.\index{ANSI C@\ac{ansi} C}
<<identifying the platform>>=
#if defined (ESV)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
@ This cover \idx{Hewlett Packard} 9000/750 (RISC) models, at least.  Others
may vary.
<<identifying the platform>>=
#if defined (__hpux) 
#  define KNOWN_MACHINE
#  define CALL_LIKE_HPUX 1
#endif
@ The support old \idx{Silicon Graphics} \idx{Iris} with 68xxx
processors is almost certainly not functional.
<<identifying the platform>>=
#if defined (iris)
#  define KNOWN_MACHINE
#  define CALL_LIKE_IRIS 1
#endif
@ \idx{Silicon Graphics} \idx{IRIX} systems \idx{Iris}es, \idx{Indigo}s,
\idx{Crimson}s etc., at least version 4 up are \ac{ansi}\index{ANSI
  C@\ac{ansi} C} and \ac{posix}\index{POSIX@\ac{posix}} compliant.
<<identifying the platform>>=
#ifdef __sgi   /* in ANSI mode */
#  ifndef sgi
#    define sgi
#  endif
#endif
#if defined (sgi)                     /* Silicon graphics with R3000's */
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
@ \idx{Solbourne}s are \idx{Sun} clones.
<<identifying the platform>>=
#if defined (solbourne) 
#  ifndef sun
#   define sun               /* don't know whether it's defined or not */
#  endif
#endif
<<identifying the platform>>=
#if defined (sun)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#  define strerror(i) sys_errlist[i] /* k&r compiler doesn't have it */
#endif
@ \idx{DEC} \idx{OSF/1} (\idx{Alpha}) and \idx{Ultrix} use the same
calling conventions, at least.  The documentation I saw for OSF/1 said
that [[__OSF1__]] is defined, but it's reported that you need
[[__osf__]] (in come cases?).
<<identifying the platform>>=
#if defined (ultrix) || defined(__OSF1__) || defined(__osf__)
#  define KNOWN_MACHINE
#  define CALL_LIKE_SUN 1
#endif
@ \idx{VMS} is a law unto itself, of course.
<<identifying the platform>>=
#if defined (VMS)
#  define KNOWN_MACHINE
#endif
#endif /* F2C */
@ If we haven't identified the system type, we want to stop with an
error message.  Indenting [[#error]] works with \ac{ansi} C\index{ANSI
  C@\ac{ansi}C} and doesn't fall over with K\&R\index{K&R@K\&R C} as
it would if un-indented even when the test is false.
<<guarded code>>=
#if ! defined (KNOWN_MACHINE)
  #error System type is not known -- see the Installation Guide
#else
<<general code>>
#endif
@ At this stage we've identified the platform and are in business.  Here
are the components we have to put together.

<<general code>>=
<<header files>>
<<[[#define]]s>>
<<global variables>>
<<internal routines>>
<<routines>>
<<AIX support>>
<<AIX and HPUX support>>

@ \section{Header files}

If the system has \ac{posix} stuff, we want to ensure it's used.
<<header files>>=
#ifndef _POSIX_SOURCE
#define _POSIX_SOURCE
#endif
<<header files>>=
#include <stdio.h>

#if defined (VMS)
#  include <descrip.h>          /* non-POSIX */
#  define NOUNISTD
#else
#  include <sys/types.h>
#  include <sys/times.h>
#endif

#ifdef stardent                 /* who knows if this works anyhow... */
#  include <sys/types.h>
#  include <malloc.h>           /* non-POSIX */
#else
#  include <stddef.h>
#endif
@ BSD might need {\tt strings.h} and [[index]] instead of [[strchr]].
This is an \ac{ansi} header, not \ac{posix.1}.
<<header files>>=
#include <string.h>
@ Some systems like \idx{ESV} don't have {\tt unistd.h}, and the
configuration makes the appropriate [[#define]] of [[NOUNISTD]].
<<header files>>=
#ifndef NOUNISTD
#  include <unistd.h>
#  include <stdlib.h> 
#else
#  ifndef VMS
#    include <sys/file.h>       /* ESV, old Concentrix */ /* non-POSIX */
#  endif
#  endif

#include <errno.h>
#  include <ctype.h>

#ifdef _AIX                     /* would do no harm on others, though */
#  include <time.h>
#endif
@ \section{{\tt define}s}
\subsection{Defaults and customisable items}

\fixme{We should be able to get help from \ac{posix} on the filename and open
files limits}
<<[[#define]]s>>=
#define MAXFLEN       500       /* the maximum length of a filename in CCP4 */
#define MAXFILES       10    /* maximum number of files open symultaneously */
#define DEFSIZE         2    /* default mode access for random access files */
@ These constants record the current i/o status of a stream (needed to
know if an [[fseek]] is needed or not before the next i/o operation).
<<[[#define]]s>>=
#define IRRELEVANT_OP   0      /* used to show if an fseek is needed or not */
#define READ_OP         1
#define WRITE_OP        2
@ \subsection{Machine dependent stuff}
These should be defined in {\tt stdlib.h}, but this isn't present, for
instance in \idx{Alliant} \idx{Concentrix} before release~3 or with the
bundled \idx{SunOS} {\tt cc}.
<<[[#define]]s>>=
#ifndef SEEK_SET
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
#endif /* ! SEEK_SET */
<<[[#define]]s>>=
#if defined (VMS)
#  define DELFILE remove
#else
#  define DELFILE unlink
#endif

#if defined (ardent) || defined (titan) || defined (stardent)
  struct Str_Desc {
    char *Str_pointer;
    int  Str_length;
    int id;
  };
#endif
@ \subsection{File mode definitions}

Here are the deinfitions of the {\tt diskio} modes, specifying the
type of data transfer: bytes, half-words, integers, reals,
half(integer)-word complex and complex, respectively:
<<[[#define]]s>>=
#define BYTE  0
#define INT16 1   
#define INT32 6
#define FLOAT32 2
#define COMP32  3
#define COMP64  4

@ \section{Global variables}
\subsection{Initialised variables}
<<global variables>>=
static char rcsid[] = "$Id$";
static int initialised =  0;    /* flag to initialise data and file streams */
static char *file_attribute[] = {"w+", "w+", "r+", "w+", "r"};/* file modes */
@ Here is a table of bytes per item for the different i/o modes
available.  Note the \idx{machine dependencies} in here.  The
\idx{assumption} is that we have a 32-bit machine and that
[[int]]$\equiv$[[INTEGER]]([[*4]]), [[short]]$\equiv$[[INTEGER*2]],
[[float]]$\equiv$[[REAL]].  \fixme{Sort out the correct values for the modes}
<<global variables>>=
static int item_sizes[] = {
  (int) sizeof (char),                                          /* 0: bytes */
#if defined (sgi)
  (int) sizeof (short),         /* silicon graphics bodge (This is fixed in
                                   IRIX4, at least) */
#else
  (int) sizeof (short int),                      /* 1: (integer) half words */
#endif
  (int) sizeof (float),                                   /* 2: reals/words */
  (int) sizeof (int),           /* 3: `short complex' (pairs of half words).
                                   NB int rather than 2*short since must fit
                                   into fortran integer */
  (int) 2*sizeof (float),                    /* 4: complex (pairs of words) */
  (int) sizeof (int),		/* 5: not used */
  (int) sizeof (int)		/* 6: integers */
};
<<global variables>>=
@ \subsection{Uninitialised variables}
<<global variables>>=
static FILE *file_stream[MAXFILES];                 /* Pointer to disk file */
static char file_name[MAXFILES][MAXFLEN];      /* Pointer to disk file name */
static int  file_bytes_per_item[MAXFILES];/* Pointer to disk file item size */
static int  file_is_scratch[MAXFILES];    /* Indicates if file is 'SCRATCH' */
static int  file_last_op [MAXFILES];    /* see man fopen rd/wr combinations */
static int file_mode[MAXFILES];	              /* diskio mode of each stream */
@ \section{Routines}

\subsection{Internal routines}

This gets the length of a \ft{} string ([[character*]]\meta{len}
variable) \meta{s} with trailing blanks removed.  \fixme{Avoid lossage
  on null/blank string}
<<internal routines>>=
static size_t flength (s, len)
char *s;
int len;
{
  while (s[--len] == ' ');
  return (++len);
}
@ This interface to [[ccperr]] avoids mixing C and \ft{} i/o, as was
originally done.\index{error reporting}
<<internal routines>>=
static void fatal (message)
char *message;
{
  int one = 1;
  int *code = &one;
  int length = strlen(message);
#if CALL_LIKE_HPUX
  extern void ccperr();

  ccperr (code, message, length);
#endif
#if CALL_LIKE_STARDENT
  extern void CCPERR();
  struct Str_Desc *str;

  str->Str_length = length;
  str->Str_pointer = message;
  (void) strncpy (str->Str_pointer, message, length);
  CCPERR (code, str);
#endif
#if defined (VMS)
  extern void CCPERR();
   struct dsc$descriptor_s *str;

   str->dsc$a_pointer = message;
   str->dsc$w_length = length;
  CCPERR (code, str);
#endif
#if CALL_LIKE_SUN
  extern void ccperr_();

  ccperr_ (code, message, length);
#endif
#if CALL_LIKE_IRIS
  extern fortran ccperr_();

  (void) ccperr_ (length, code, message);
#endif
 }
@ 
\subsection{{\tt subroutine ustenv(\meta{string}, \meta{result})}}

This sets an environment variable \meta{var} to \meta{val}, where the
argument \meta{string}[[==']]\meta{var}[['//'='//']]\meta{val}[[']].
This is for use by the `\idx{logical name}' mechanism for specifying
file connexions.  Note that a \idx{VMS} varsion is supplied in {\tt
  vms.for} and that there is no standard way of setting and
environment variable.  In a minimal \ac{posix} system it might be
necessary to twiddle the environment strings explicitly.

<<routines>>=
#if ! defined (VMS)

#if CALL_LIKE_HPUX
  void ustenv (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_STARDENT
  void USTENV (str, result)
  struct Str_Desc *str;
#endif
#if CALL_LIKE_SUN
  void ustenv_ (str, result, Lstr)
  char *str;
  int  Lstr;
#endif
#if CALL_LIKE_IRIS
  fortran ustenv_ (Lstr, str, result)
  char *str;
  int  Lstr;
#endif

int *result;
{
  size_t Length;
  char name[MAXFLEN], value[MAXFLEN], *temp;

#if CALL_LIKE_STARDENT
  Length = flength (str->Str_pointer, str->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str->Str_pointer, Length);
#else
  Length = flength (str, Lstr);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (name, str, Length);
#endif
  name[Length] = '\0'; 

#if defined (sgi) || defined (sun) || defined (__hpux) || \
    defined(_AIX) || defined(ultrix)
      /* putenv is the POSIX.1, draft 3 proposed mechanism */
      /* ESV seems to have it in the SysVile universe */
  temp = (char *) malloc (MAXFLEN);
  if (temp == NULL) fatal("USTENV: Memory allocation failed");
  (void) strcpy (temp, name);
  *result = putenv (temp);
  /* note the necessary lack of free() */
#else
  /* setenv is not POSIX */
  temp = (char *) strchr (name, '='); /* BSD might have to use `index' */
  if (temp != NULL) {
    *temp = '\0';
    temp++;
    (void) strcpy (value, temp);
  };
  *result = setenv (name, value, 1);
#endif
}

#endif  /* end of #if ! defined (VMS) */
@ \subsection{{\tt subroutine cunlink (\meta{filename})}}
This unlinks \meta{filename} from the directory.  It's intended for
use with scratch files, so that they can be hidden when opened but
still be available as long as they remain connected (see [[CCPOPN]]).
<<routines>>=
#if CALL_LIKE_HPUX
  void cunlink (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void CUNLINK (filename)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void CUNLINK (filename)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void cunlink_ (filename, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran cunlink_ (Lfilename, filename)
  char *filename;
  int  Lfilename;
#endif
{
  size_t Length;
  char tempfile[MAXFLEN];

#if CALL_LIKE_STARDENT
    Length = flength (filename->Str_pointer, filename->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->Str_pointer, Length);
#else
#  if ! defined (VMS)
    Length = flength (filename, Lfilename);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename, Length);
#  else
    Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (tempfile, filename->dsc$a_pointer, Length);
#  endif
    tempfile[Length] = '\0';
    if (DELFILE (tempfile) != 0)
      fatal("Can\'t unlink");
#endif
}
@ \subsection{{\tt subroutine copen(\meta{iunit}, \meta{filename}, \meta{istat})}}
<<routines>>=
#if CALL_LIKE_HPUX
  void copen (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_STARDENT
  void COPEN (iunit, filename, istat)
  struct Str_Desc *filename;
#endif
#if defined (VMS)
  void COPEN (iunit, filename, istat)
  struct dsc$descriptor_s *filename;
#endif
#if CALL_LIKE_SUN
  void copen_ (iunit, filename, istat, Lfilename)
  char *filename;
  int  Lfilename;
#endif
#if CALL_LIKE_IRIS
  fortran copen_ (iunit, Lfilename, filename, istat)
  char *filename;
  int  Lfilename;
#endif

int  *iunit, *istat;
{
  size_t Length;
  int i, jstat;
  int16 fileFT, fileIT;         /* machine type stamps in file */
  unsigned char mtstring[2];    /* machine stamp */

  jstat = *istat;
  if (! initialised) {
    /* note that array element 0 is unused -- using it produced
       complaints from mtzlib about a zero stream */
    for (i = 1; i < MAXFILES; i++) {
      file_stream[i]         = NULL;
      file_name[i][0]        = '\0';
      file_bytes_per_item[i] = item_sizes[DEFSIZE];  /* default item size */
      file_is_scratch[i]     = 0;
      file_last_op[i]        = IRRELEVANT_OP;
    }
    initialised = 1;
  }
  for (i = 1; i < MAXFILES; i++) /* Find next available stream */
    if (file_stream[i] == NULL) break;
  if (i == MAXFILES) {
    *iunit = -1;                /* return no more units flag */
    return;
  } else {
    *iunit = i;}                 /* will return the stream number */
#if CALL_LIKE_STARDENT
  Length = flength (filename->Str_pointer, filename->Str_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->Str_pointer, Length);
#else
#  if defined (VMS)
  Length = flength (filename->dsc$a_pointer, filename->dsc$w_length);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename->dsc$a_pointer, Length);
#  else
  Length = flength (filename, Lfilename);
  if (Length > MAXFLEN) Length = MAXFLEN - 1;
  (void) strncpy (file_name[i], filename, Length);
#  endif
#endif
  file_name[i][Length] = '\0';
  file_last_op[i] = IRRELEVANT_OP;
  file_bytes_per_item[i] = item_sizes[DEFSIZE]; /* default item size */
  file_is_scratch[i] = (jstat == 2);
  file_stream[i] = fopen (file_name[i], file_attribute[jstat - 1]);
  if (file_stream[i] == NULL) {
    i = -2;                     /* return open failure flag */
    return; }
  if (file_is_scratch[i] && DELFILE (file_name[i])!=0)
      fatal ("(Q)QOPEN: error unlinking scratch file");
  <<set up number conversion for read if necessary>>
  if (fseek (file_stream[*iunit], 0L, SEEK_SET) != 0)
    fatal("(Q)QOPEN: fseek failed");
  *iunit = i;
}
@ For non-scratch map or MTZ files, we set flags in [[Iconvert]] and
[Fconvert]] to indicate whether or not integer and floating point
numbers in the file are in a foreign format and, if so, what that
format is, as determined by the machine stamp in the file.  If the
stamp is zero (as it would be for files written with a previous
version of the library) we assume the file is in native format and
needs no conversion in [[qread]].  We don't check various error
returns here, since a random file might have rather few bytes in it
and we don't assume that we can read any particular part of it.
<<set up number conversion for read if necessary>>=
Fconvert[*iunit] = Iconvert[*iunit] = 0;
fileFT = fileIT =0;
if ((*file_attribute[*istat - 1] != 'w') &&
    (! file_is_scratch[*iunit]) &&
    (fread (fileType[*iunit], (size_t) sizeof(char), (size_t) 4,
            file_stream[*iunit]) == 4))
{
  if (strncmp (fileType[*iunit],"MTZ",3) == 0) { /* MTZ file? */
    if ((fseek (file_stream[*iunit], mt_stamp_posn, SEEK_SET) == 0)
	&& (fread (mtstring,(size_t)  sizeof(char), (size_t) 2,
		   file_stream[*iunit]) == 2)) {
    } else {
      fatal("(Q)QOPEN: can't read machine stamp in MTZ file");}
  } else {			/* map file? */
    if (fseek (file_stream[*iunit], map_stamp_posn, SEEK_SET)==0 &&
	(fread (fileType[*iunit], (size_t) sizeof(char), (size_t) 4,
		file_stream[*iunit]) == 4) &&
	(strncmp(fileType[*iunit],"MAP",3) == 0)) {
      if (fread (mtstring, (size_t) sizeof(char), (size_t) 2,
		 file_stream[*iunit]) != 2)
	fatal("(Q)QOPEN: can't read machine stamp in map file");
    }
  }
}
errno = 0;                    /* in case of unchecked i/o error above */
fileIT = (mtstring[1]>>4) & 0x0f;
fileFT = (mtstring[0]>>4) & 0x0f;
/* Record the need for conversion and what the file type is: */
if (fileFT != 0 && fileFT != userFT)
     Fconvert[*iunit] = fileFT;  /* else assume native */
if (fileIT != 0 && fileIT != userIT)
     Iconvert[*iunit] = fileIT;  /* else assume native */
@ \subsection{{\tt subroutine qclose (\meta{iunit})}}
Closes the \idx{diskio} file open on unit \meta{iunit}.
<<routines>>= 
#if CALL_LIKE_HPUX
  void qclose (iunit)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QCLOSE (iunit)
#endif
#if CALL_LIKE_SUN
  void qclose_ (iunit)
#endif
#if CALL_LIKE_IRIS
  fortran qclose_ (iunit)
#endif

int *iunit;
{
  if (! initialised) 
    fatal ("QCLOSE: qopen/qqopen not yet called");

  if (file_stream[*iunit] != NULL) {
    if (fclose (file_stream[*iunit]) == EOF) 
      fatal ("QCLOSE: failed"); /* fixme: add file name to message */
    file_stream[*iunit] = NULL;
  }
  file_name[*iunit][0] = '\0';
}
@ \subsection{{\tt subroutine qmode (\meta{iunit}, \meta{mode},
    \meta{size})}}
Changes the \idx{diskio} \idx{access mode}.  At present it does this
globally rather than just for \meta{iunit}.  \fixme{Investigate
  whether anything will break if this is done properly per-unit}
The resulting size in bytes of items for transfer is returned as
\meta{size}.
<<routines>>=
#if CALL_LIKE_HPUX
  void qmode (iunit, mode, size)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QMODE (iunit, mode, size)
#endif
#if CALL_LIKE_SUN
  void qmode_ (iunit, mode, size)
#endif
#if CALL_LIKE_IRIS
  fortran qmode_ (iunit, mode, size)
#endif

int *iunit, *mode, *size;
{
  if (! initialised) 
    fatal ("QMODE: qopen/qqopen not yet called");

  if (*mode >= 0 && *mode <= 6 && *mode != 5)
    file_bytes_per_item[*iunit] = item_sizes[*mode];
  else
    fatal ("QMODE: bad mode");
  *size = file_bytes_per_item[*iunit];       /* return number of bytes/item */
  file_mode[*iunit] = *mode;
}
@ \subsection{{\tt subroutine qread(\meta{iunit}, \meta{buffer},
    \meta{nitems}, \meta{result})}}

Reads \meta{nitems} in the current mode (set by [[qmode]]) from stream
\meta{iunit} previously opened by [[qopen]](/[[copen]]) and returns
\meta{result} which is the number of items read or [[0]] on failure.
Numbers written in a foreign format will be traslated if necessary if
the stream is connected to an MTZ or map file.
<<routines>>=
#if CALL_LIKE_HPUX
  void qread (iunit, buffer, nitems, result)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QREAD (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_SUN
  void qread_ (iunit, buffer, nitems, result)
#endif
#if CALL_LIKE_IRIS
  fortran qread_ (iunit, buffer, nitems, result)
#endif

uint8 * buffer;
int *iunit, *nitems, *result;
{
  int i, nbytes, n;

  if (! initialised) 
    fatal ("QREAD: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == WRITE_OP &&
      fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0) {
      *result = -1;
      return;
    }
  file_last_op[*iunit] = READ_OP;
  nbytes = *nitems * file_bytes_per_item[*iunit];
  i = fread (buffer, (size_t) file_bytes_per_item[*iunit], 
                (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) {
    if (i == 0) *result = -1;   /* fixme: should use feof */
    else *result = i;
    return;
  }
  *result = 0;
  n = *nitems;
  switch (file_mode[*iunit]) {
  case BYTE:
    break;
  case INT16:
    if (Iconvert[*iunit])
      <<convert [[n]] short integers in [[buffer]]>>
    break;
  case INT32:
    if (Iconvert[*iunit])
      <<convert [[n]] long integers in [[buffer]]>>
    break;
  case FLOAT32:
    if (Fconvert[*iunit])
      <<convert [[n]] reals in [[buffer]]>>
    break;
  case COMP32:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of ints */
      <<convert [[n]] short integers in [[buffer]]>>
    }
    break;
  case COMP64:
    if (Fconvert[*iunit]) {
      n = 2*n;                  /* pairs of reals */
      <<convert [[n]] reals in [[buffer]]>>
    }
    break;
  default:
    fatal ("QREAD: Bad mode");
  }
}
@ \subsection{{\tt qwrite (\meta{iunit}, \meta{buffer},
    \meta{nitems})}}
This write \meta{nitems} items from \meta{buffer} to [[qopen]]ed
stream \meta{iunit} using the current mode.
<<routines>>=
#if CALL_LIKE_HPUX
  void qwrite (iunit, buffer, nitems)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QWRITE (iunit, buffer, nitems)
#endif
#if CALL_LIKE_SUN
  void qwrite_ (iunit, buffer, nitems)
#endif
#if CALL_LIKE_IRIS
  fortran qwrite_ (iunit, buffer, nitems)
#endif
uint8 * buffer;
int *iunit, *nitems;
{
  int i;

  if (! initialised) 
    fatal ("QWRITE: qopen/qqopen not yet called");
  if (file_last_op[*iunit] == READ_OP)
    if (fseek (file_stream[*iunit], 0L, SEEK_CUR) != 0)
      fatal ("QWRITE: i/o error");
  file_last_op[*iunit] = WRITE_OP;
  i = (int) fwrite (buffer, (size_t) file_bytes_per_item[*iunit],
                    (size_t) *nitems, file_stream[*iunit]);
  if (i != *nitems) fatal ("QWRITE: i/o error");
}

/****************************************************************************
 * Routine: qseek                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qseek (iunit, irecl, iel, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QSEEK (iunit, irecl, iel, lrecl)
#endif
#if CALL_LIKE_SUN
  void qseek_ (iunit, irecl, iel, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qseek_ (iunit, irecl, iel, lrecl)
#endif

int *iunit, *irecl, *iel, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSEEK: qopen/qqopen not yet called");
  position = (long) ((*lrecl)*(*irecl - 1) + (*iel - 1));
  position *= (long) file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSEEK failed");     /* fixme: add file info */
} /* End of qseek */

/****************************************************************************
 * Routine: qback                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qback (iunit, lrecl)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QBACK (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qback_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qback_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QBACK: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) - (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit], position, SEEK_SET) != 0)
    fatal ("QBACK failed");     /* fixme: add file info */
}

/****************************************************************************
 * Routine: qskip                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qskip (iunit, lrecl)
#endif
#if defined (VMS) || defined (ardent) || defined (titan) || defined (stardent)
  void QSKIP (iunit, lrecl)
#endif
#if CALL_LIKE_SUN
  void qskip_ (iunit, lrecl)
#endif
#if CALL_LIKE_IRIS
  fortran qskip_ (iunit, lrecl)
#endif

int *iunit, *lrecl;
{
  long int position;

  if (! initialised) 
    fatal ("QSKIP: qopen/qqopen not yet called");
  position = ftell (file_stream[*iunit]) +
    (*lrecl)*file_bytes_per_item[*iunit];
  file_last_op[*iunit] = IRRELEVANT_OP;
  if (fseek (file_stream[*iunit],position,SEEK_SET) != 0)
    fatal ("QSKIP failed");     /* fixme: add file info */
}

/****************************************************************************
 * Routine: cqinq                                                           *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void cqinq (iunit, filnam, length, len_filnam)
  char *filnam; 
  int len_filnam;
#endif
#if CALL_LIKE_STARDENT
  void CQINQ (iunit, filnam, length)
  struct Str_Desc *filnam;
#endif
#if defined (VMS)
  void CQINQ (iunit, filnam, length)
  struct dsc$descriptor_s *filnam;
#endif
#if CALL_LIKE_SUN
  void cqinq_ (iunit, filnam, length, len_filnam)
  char *filnam;
  int len_filnam;
#endif
#if CALL_LIKE_IRIS
  fortran cqinq_ (iunit, len_filnam, filnam, length)
  char *filnam;
  int len_filnam;
#endif

int *iunit, *length;
{
  char real_name[MAXFLEN];
  int stream, Length, i;
  long position;

  if (! initialised) 
    fatal ("QQINQ:,qopen/qqopen not yet called");
  *length = -1;                                    /* default return value */
  stream = *iunit;
  if (file_stream[stream] == NULL) { 
    /* no unit open -- try file name */
#if CALL_LIKE_STARDENT
    Length = flength (filnam->Str_pointer, filnam->Str_length);
    if (Length > MAXFLEN) Length = MAXFLEN - 1;
    (void) strncpy (real_name, filnam->Str_pointer, Length);
#else
#  if defined (VMS)
     Length = flength (filnam->dsc$a_pointer, filnam->dsc$w_length);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam->dsc$a_pointer, Length);
#  else
     Length = flength (filnam, len_filnam);
     if (Length > MAXFLEN) Length = MAXFLEN - 1;
     (void) strncpy (real_name, filnam, Length);
#  endif
#endif
    real_name[Length] = '\0';
    for (i = 1; i < MAXFILES; i++)
      if (! strcmp (real_name, file_name[i])) break;
    stream = i % MAXFILES;
  }
  if (file_stream[stream] != NULL) {
    file_last_op[stream] = IRRELEVANT_OP;
    (void) fflush (file_stream[stream]);               /* flush the output stream */
#if 0
    /* checking the return value reportedly causes problems in ultrix
       under unknown circumstances... */
    if (fflush (file_stream[stream]) != 0) fatal ("QQINQ: flush failed");
#endif
    position = ftell (file_stream[stream]);   /* remember current position */
    (void) fseek (file_stream[stream],0L,SEEK_END); /* seek EOF */
    *length = (int) ftell (file_stream[stream]); /* get file size */
    if (fseek (file_stream[stream],position,SEEK_SET) != 0) /* seek position */
      fatal ("QQINQ: seek failed"); /* fixme: add file info */
  }
} /* End of cqinq */

/****************************************************************************
 * Routine: qlocate                                                         *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qlocate (iunit, locate)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QLOCATE (iunit, locate)
#endif
#if CALL_LIKE_SUN
  void qlocate_ (iunit, locate)
#endif
#if CALL_LIKE_IRIS
  fortran qlocate_ (iunit, locate)
#endif

int *iunit, *locate;
{
  if (! initialised) 
    fatal ("QLOCATE: qopen/qqopen not yet called");
  *locate = -1;
  if (file_stream[*iunit] != NULL)
    *locate = (int) ftell (file_stream[*iunit]) / file_bytes_per_item[*iunit];
} /* End of qlocate */

/****************************************************************************
 * Routine: qtype                                                          *
 ****************************************************************************/

#if CALL_LIKE_HPUX
  void qtype (istamp)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  void QTYPE (istamp)
#endif
#if CALL_LIKE_SUN
  void qtype_ (istamp)
#endif
#if CALL_LIKE_IRIS
  fortran qtype_ (istamp)
#endif
  int *istamp;
{
  *istamp = DF_MT;
}
@ \section{Missing system support}

Routines often found in {\tt \idx{libU77}.a} or somesuch are missing
on some systems.\index{HPUX}\index{AIX}
<<AIX support>>=
#ifdef _AIX
void idate (d, m, y)
     int *y, *m, *d;
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     *y = lt->tm_year + 1000; *m = lt->tm_mon; *d = lt->tm_mday;
}
#endif                          /* _AIX */

<<AIX and HPUX support>>=
#if defined (__hpux) || defined (_AIX)
void gerror (str, Lstr)
char *str;
int  Lstr;
{
  int i;

  if (errno == 0) {             /* Avoid `Error 0' or some such message */
    for (i=1; Lstr; i++)
      str[i] = ' ';
  } else {
    (void) strncpy (str, strerror (errno), Lstr);
    for (i = strlen (str); i < Lstr; i++) str[i] = ' ';  /* pad with spaces */
  }
} /* End of gerror (str, Lstr) */

int ierrno () {
  return errno;
}

void itime (array)
     int array[3];
{
     struct tm *lt;
     time_t tim;
     tim = time(NULL);
     lt = localtime(&tim);
     array[0] = lt->tm_hour; array[1] = lt->tm_min; array[2] = lt->tm_sec;
}

#if 0                           /* dtime isn't used at present */
static long clk_tck = 0;

float dtime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  static time_t old_utime = 0, old_stime = 0;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  utime = buffer.tms_utime; stime = buffer.tms_stime;
  tarray[0] = ((float)(utime - old_utime)) / (float)clk_tck;
  tarray[1] = ((float)(stime - old_stime)) / (float)clk_tck;
  old_utime = utime; old_stime = stime;
  return (tarray[0]+tarray[1]);
}
#endif                          /* dtime */

float etime (tarray)
     float tarray[2];
{
  struct tms buffer;
  time_t utime, stime;
  if (! clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
  (void) times(&buffer);
  tarray[0] = (float) buffer.tms_utime / (float)clk_tck;
  tarray[1] = (float) buffer.tms_stime / (float)clk_tck;
  return (tarray[0]+tarray[1]);
}

#endif  /* AIX || HPUX */
@ \section{Converting foreign binary number formats}

The library is intended to allow the binary file formats (\idx{MTZ}
and map\index{map files}) to be read satisfactorily if they were
written on another platform.  Such files are always written in the
{\em native\/} real or integer number format with a `\idx{machine
  stamp}' in the file to identify the formats involved.  Then, if
necessary, conversion is done from the foriegn format to native when
the file is read.  There is thus only an overhead for files imported
from platforms with different number formats; locally-written files
are read back optimally and there is no write overhead.  This is in
contrast, for instance, to the \idx{XDR} approach (and \idx{HDF}?),
where a canonical external format is used.

When converting from foreign to native formats we're potentially faced
with a combinatorial explosion---currently combinations of \ac{ieee}
little-endian, \ac{ieee} big-endian, \idx{VAX} and \idx{Convex} native
formats.  (This applies only to real number formats---fortunately
everything else seems to have twos complement integers.)  Thus we
first make sure that the format is converted to canonical form (which
we choose to be to big-endian \ac{ieee}, following XDR) and then, if
necessary, to the native format ina separate stage.  This is going to
be somewhat slower than it might be, but what the heck\dots{}

The basic idea of this is due to David Wild (EMBL, Hamburg, 1991).
The original, partially-functional implementation used code from the
\idx{HDF} 3.1 distribution.  This re-write is by Dave Love, based on
HDF3.3, but doing the conversion in-place.  (HDF stuff can be found on
{\tt ftp.ncsa.uiuc.edu}.)

\subsection{`Machine stamps'}

Here's how we specify the number formats for machines.  The
`\idx{machine stamp}' is a 32-bit quantity containing set
of four `nibbles' (half-bytes).  Each nibble is a number specifying
the representation of (in C terms) [[double]] ($d$), [[float]] ($f$),
[[int]] ($i$)) and [[unsigned char]] ($c$) types.  Because this stamp
is written as an integer in {\tt mtzlib.for} and {\tt
  maplib.for},\index{mtzlib.for@{\tt mztlib.for}}\index{maplib.for@{\tt
    maplib.for}} it is byte-sex-dependent, sigh.  Thus each stamp is
of the form
\[\mbox{{\tt 0x}}dfic0000\qquad\mbox{big endian}\]
or
\[\mbox{{\tt 0x}}0000cifd\qquad\mbox{little endian}\]
so that it always appears in the file as if written on a big endian
machine.  The values for the nibbles may be taken from the list (following
HDF):
\begin{quote}
  \begin{tabular}{ll}
      1 & Big-endian \ac{ieee}\\
      2 & VAX \\
      3 & Cray \\
      4 & Little-endian \ac{ieee}\\
      5 & Convex native \\
      6 & Fijitsu VP
  \end{tabular}
\end{quote}
\idx{Cray} isn't relevant to us because it's not a 32-bit machine
and we don't currently have a use for the \idx{Fujitsu} one, which isn't
implemented here.  We ignore the possibility of
non-\ac{ascii}\index{ASCII@ac{ascii}} characters which might need
converting e.g., from \ac{ebcdic}\index{EBCDIC@\ac{ebcdic}}.  See the
\idx{HDF} code for possibilities.

Here are the tags for different formats (`\idx{class info codes}'),
not all relevant:
<<[[#define]]s>>=
/* class info codes for int */
#define DFNTI_MBO       1       /* Motorola byte order 2's compl */
#define DFNTI_IBO       4       /* Intel byte order 2's compl */

/* class info codes for float */
#define DFNTF_BEIEEE    1       /* big endian IEEE (canonical) */
#define DFNTF_VAX       2       /* Vax format */
#define DFNTF_CONVEXNATIVE 5    /* Convex native floats */
#define DFNTF_LEIEEE    4       /* little-endian IEEE format */

@ Here are the possibilties for the machine stamp:
<<[[#define]]s>>=
#define DFMT_BEIEEE             0x11110000 /* bigendian IEEE (canonical) */
#define DFMT_LEIEEE             0x00004441 /* little endian IEEE */
#define DFMT_VAX                0x00004122 /* VAX (not Alpha) */
#define DFMT_VP                 0x66110000 /* IBM clone */
#define DFMT_CONVEXNATIVE       0x55110000 /* Convex without IEEE unit */

@ The \idx{machine stamp} is [[DF_MT]].  Here are the definitions
we're interested in.  Note\index{assumption} that some of the symbols
tested here to determine the machine type might need to be qualified
in the future where they don't necessarily determine the architecture.
First an obvious one:
<<[[#define]]s>>=
#ifdef VAX
#  define DF_MT   DFMT_VAX
#endif
@ Here are the possibilities for little=endian \ac{ieee}.  (The
\idx{MIPS} compilers define [[MIPSEL]] or [[MIPSEB]] depending on the
mode in which the the chip operates.)  The architectures covered here
include some RS\meta{nnnn} (e.g., \idx{DECstations}), \idx{i860} and
other \idx{Intel} chips like \idx{PCs} and \idx{Alpha}.
<<[[#define]]s>>=
#if defined(MIPSEL) || defined(alliant) || defined(__ALPHA) || defined(i386)
#  define DF_MT   DFMT_LEIEEE
#endif
@ Big-endian \ac{ieee} includes other RS\meta{nnnn} like SGI machines,
\idx{HP} beasts (\idx{68k}-based or \idx{RISC}), \idx{RS/6000} and all
\idx{Sun}s except the obsolete i386-based ones.
\idx{Apollo}s are also apparently in this category.
<<[[#define]]s>>=
/* the VAX VMS compiler objected to splitting this line */
#if defined(MIPSEB) || defined(__hpux) || defined(_AIX) || defined(m68k) || defined(mc68000) || defined(sparc)
#  define DF_MT   DFMT_BEIEEE
#endif
@ \idx{Convex}s can operate in either native or \ac{ieee} mode:
<<[[#define]]s>>=
#if defined(convex) || defined(__convex__)
#  ifdef _IEEE_FLOAT_
#    define DF_MT DFMT_BEIEEE
#  else
#    ifdef _CONVEX_FLOAT_
#      define DF_MT DFMT_CONVEXNATIVE
#    else
       #error "Can't determine Convex floating point type (use native compiler)"
#    endif
#  endif
#endif

#ifndef DF_MT
  #error "Can't determine DF_MT (machine number format)"
#endif
@ Here are the codes for data types.
<<[[#define]]s>>=
#define DFNT_UINT       0       /* unsigned int */
#define DFNT_SINT       1       /* short int */
#define DFNT_INT        2       /* int */
#define DFNT_UCHAR      3       /* unsigned char */
#define DFNT_CHAR       4       /* char */
#define DFNT_FLOAT      5       /* float */
#define DFNT_DOUBLE     6       /* double */
#define map_stamp_posn  208L	/* machine stamp offset in map header */
#define mt_stamp_posn   8L	/* machine stamp offset in MTZ header */
<<global variables>>=
typedef short int16;
typedef unsigned long uint32;
typedef float float32;
typedef unsigned char uint8;

union float_uint_uchar {
    float32 f;
    uint32 i;
    uint8 c[4]; };
#if DF_MT == DFMT_BEIEEE
static int16 userIT = (int16) DFNTI_MBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_BEIEEE; /* machine float type */
#endif
#if DF_MT == DFMT_LEIEEE
static int16 userIT = (int16) DFNTI_IBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_LEIEEE; /* machine float type */
#endif
#if DF_MT == DFMT_VAX
static int16 userIT = (int16) DFNTI_IBO; /* machine integer type */ 
static int16 userFT = (int16) DFNTF_VAX; /* machine float type */
#endif
#if DF_MT == DFMT_CONVEXNATIVE
static int16 userIT = (int16) DFNTI_MBO; /* machine integer type */ 
static int16 userFT = (int16) DFMT_CONVEXNATIVE; /* machine float type */
#endif
static int
    Iconvert[MAXFILES],         /* integer convserion needed on read*/
    Fconvert[MAXFILES];         /* real convserion needed on read*/
static char fileType[MAXFILES][4]; /* MAP/MTZ stamp */
@ \subsubsection{Converting integers}
<<convert [[n]] short integers in [[buffer]]>>=
{
if ((Iconvert[*iunit]==DFNTI_MBO && userIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && userIT==DFNTI_MBO)) {
  char j;
  for (i=0; i < n*2; i+=2) {
    j = buffer[i];
    buffer[i] = buffer[i+1];
    buffer[i+1] = j; } }
else
  fatal("QREAD: bad file type in conversion");
}
<<convert [[n]] long integers in [[buffer]]>>=
{
if ((Iconvert[*iunit]==DFNTI_MBO && userIT==DFNTI_IBO) ||
    (Iconvert[*iunit]==DFNTI_IBO && userIT==DFNTI_MBO))
  <<byte-swap [[n]] full words in [[buffer]]>>
else
  fatal("QREAD: bad file type in conversion");
}
@ \subsubsection{Converting reals}
<<convert [[n]] reals in [[buffer]]>>=
{
switch (Fconvert[*iunit]) {	/* get to BE IEEE */
   case DFNTF_VAX :
     vaxF2ieeeF(buffer, n);
     break;   
   case DFNTF_CONVEXNATIVE :
     convexF2ieeeF(buffer, n);
     break;
   case DFNTF_BEIEEE :
     break;
   case DFNTF_LEIEEE :
     <<byte-swap [[n]] full words in [[buffer]]>>
     break;
   default :
     fatal("QREAD: bad file type in conversion");
   }
@ We've now got a guaranteed big-endian \ac{ieee} [[buffer]].  Turn it
into the native form if necessary.
<<convert [[n]] reals in [[buffer]]>>=
switch (userFT) {
  case DFNTF_BEIEEE :
    break;                      /* done enough */
  case DFNTF_LEIEEE :
    <<byte-swap [[n]] full words in [[buffer]]>>
    break;
  case DFNTF_CONVEXNATIVE :
    ieeeF2convexF(buffer, n);
    break;
  case DFNTF_VAX :
    ieeeF2vaxF(buffer, n);
    break;
  default :
    fatal("QREAD: bad native type in conversion");
  }
}
<<byte-swap [[n]] full words in [[buffer]]>>=
{
  char j;
  for (i=0; i < n*4; i+=4) {
    j = buffer[i];
    buffer[i] = buffer[i+3];
    buffer[i+3] = j;
    j = buffer[i+1];
    buffer[i+1] = buffer[i+2];
    buffer[i+2] =j; }
}
@ \section{Non-\ac{ieee} floating-point conversion}

These conversion routines are based on \idx{HDF}, but I think you
could do it better with bit-fields in a structure representing the
sign, exponent and mantissa (does K\&R have bit fields?)\dots
<<internal routines>>=
static void vaxF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[1] @<< 1) | (buffer[i].c[0] >> 7); /* extract exponent */
    if (!exp && !buffer[i].c[1])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[1] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[0];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    } else if (exp) {           /* denormalized number */
      int shft;

      out.c[0] = buffer[i].c[1] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[0] & 0x7f) >> shft) |
        (uint8)(0x10 @<< exp);
      out.c[2] = (uint8)(buffer[i].c[0] @<< (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
      out.c[3] = (uint8)(buffer[i].c[3] @<< (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[0] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
    }
    buffer[i] = out;            /* copy back result */
  }
}

static void ieeeF2vaxF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i<size; i++) {
    exp = (buffer[i].c[0]@<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[0] = buffer[i].c[1];
      out.c[2] = buffer[i].c[3];
      out.c[3] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[0] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[1] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[0] = (uint8)(buffer[i].c[1] @<< shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[2] @<< shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[3] @<< shft);
      out.c[1] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[1] |= 0x01;
        out.c[0] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
@ The \idx{Convex} format is like the \idx{VAX} with a different byte
order.  Convex does provide \ac{ieee}$\leftrightarrow$native
conversion routines, but we need [[convexF2ieeeF]] anyhow.
<<internal routines>>=
static void convexF2ieeeF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;
  
  for (i = 0; i < size; i++) {
    exp = (buffer[i].c[0]@<<1) | (buffer[i].c[1]>>7); /* extract exponent */
    if (!exp && !buffer[i].c[0])        /* zero value */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    else if (exp > 2) {         /* normal value */
      out.c[0] = buffer[i].c[0] - (uint8)1; /* subtracts 2 from exponent */
      /* copy mantissa, LSB of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    } else if (exp) {           /* denormalized number */
      int shft;
      
      out.c[0] = buffer[i].c[0] & 0x80; /* keep sign, zero exponent */
      shft = 3 - exp;
      /* shift original mant by 1 or 2 to get denormalized mant */
      /* prefix mantissa with '1'b or '01'b as appropriate */
      out.c[1] = (uint8)((buffer[i].c[1] & 0x7f) >> shft) |
        (uint8)(0x10 @<< exp);
      out.c[2] = (uint8)(buffer[i].c[1] @<< (8-shft)) |
        (uint8)(buffer[i].c[2] >> shft);
      out.c[3] = (uint8)(buffer[i].c[2] @<< (8-shft)) |
        (uint8)(buffer[i].c[3] >> shft);
    } else {                    /* sign=1 -> infinity or NaN */
      out.c[0] = 0xff;          /* set exp to 255 */
      /* copy mantissa */
      out.c[1] = buffer[i].c[1] | (uint8)0x80; /* LSB of exp = 1 */
      out.c[2] = buffer[i].c[2];
      out.c[3] = buffer[i].c[3];
    }
    buffer[i] = out;            /* copy back result */
  }
}

static void ieeeF2convexF(buffer, size)
union float_uint_uchar buffer[];
int size;
{
  union float_uint_uchar out;
  unsigned char exp;
  int i;

  for (i=0; i < size; i++) {
    exp = (uint8)(buffer[i].c[0] @<< 1) |
      (uint8)(buffer[i].c[1] >> 7); /* extract exponent */
    if (exp) {                  /* non-zero exponent */
      /* copy mantissa, last bit of exponent */
      out.c[1] = buffer[i].c[1];
      out.c[3] = buffer[i].c[3];
      out.c[2] = buffer[i].c[2];
      if (exp < 254)            /* normal value */
        out.c[1] = buffer[i].c[0] + (uint8)1; /* actually adds two to exp */
      else {                    /* infinity or NaN */
        if (exp == 254)         /* unrepresentable - OFL */
          /* set mant=0 for overflow */
          out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0; 
        out.c[1] &= 0x7f;       /* set last bit of exp to 0 */
        out.c[0] = 0x80;        /* sign=1 exp=0 -> OFL or NaN.  this will raise
                                   a reserved operand exception if used. */
      }
    } else if (buffer[i].c[1] & 0x60) { /* denormalized value */
      int shft;
      
      shft = (buffer[i].c[1] & 0x40) ? 1 : 2; /* shift needed to normalize */
      /* shift mantissa */
      /* note last bit of exp set to 1 implicitly */
      out.c[1] = (uint8)(buffer[i].c[1] @<< shft) |
        (uint8)(buffer[i].c[2] >> (8-shft));
      out.c[2] = (uint8)(buffer[i].c[2] @<< shft) |
        (uint8)(buffer[i].c[3] >> (8-shft));
      out.c[3] = (uint8)(buffer[i].c[3] @<< shft);
      out.c[0] = (uint8)(buffer[i].c[0] & 0x80); /* sign */
      if (shft==1) {            /* set exp to 2 */
        out.c[0] |= 0x01;
        out.c[1] &= 0x7f;       /* set LSB of exp to 0 */
      }
    } else                      /* zero */
      out.c[0] = out.c[1] = out.c[2] = out.c[3] = 0;
    buffer[i] = out;            /* copy back the result */
  }
}
@ \section{`Magic' numbers}

When, for instance, an $F$ is unobserved in a derivative, we might
want to give it a special value---a `\idx{magic number}'---possibly in
addition to a special value of the $\sigma$, like a negative one.
Using such a number in a calculation (by mistake, through ignoring the
value of $\sigma$, say) should not allow one to get half-sensible
results as one might if this number was $-9999$ or some such.  (There
is non enforced connexion between the $F$ and its $\sigma$ in the MTZ
file, although one could think of adding extra columns to the file
with bit-encoded flags telling whether the $F$ in a given column was
observed.)

The obvious tactic with \ac{ieee} arithmetic is to use a \idx{NaN}
value in such situations.  Things may be set up so that we either get
an exception on using it in arithmetic or it silently progates to all
values using it and its presence is indicated by a NaN in the output.
On a \idx{VAX} architecture we can't use NaN, but there is the
possibility of using a `\idx{reserved operand}' (`\idx{Rop}')value,
which will cause an exception (by experiment: when used for
floating-point arithmetic {\em or\/} printed, but not when assigned).
The \idx{Convex} native mode is similar, except that the Rop may be
printed (in the form {\tt Rop0x}\meta{fraction part}).

On, say, the \idx{IBM 370 architecture}---which we don't currently
support---anything's a valid floating point number, and the best ploy
is probably to use the largest representable number as the `magic'
value.  This would stand a good chance of raising an overflow
exception if used.  Anyhow, if such bad use of an undefined value is
made in a program due to insufficient checking by the code, it should
be spotted on the \ac{ieee} systems and the bug fixed---it's not
strictly necessary that it should cause a fatal error on all
architectures.

We need to provide a means of setting the magic number and checking
whether a given value is such.  These are architecture-dependent
bit-level operations, hence their presence in the C code.

\subsection{Setting a value: {\tt real function qnan()}}

This was initially implemented as a subroutine taking a [[float]]
argument whose value was set to the relevant bit-pattern through a
[[union]].  This was in case assignment of an invalid value to
a floating point number could cause an exception in any
circumstances---it doesn't on any of the architectures supported at
present, so we assume\index{assumption} it's OK to provide this
[[REAL]]-valued function as requested by Phil Evans.  
<<magic numbers>>=
#if CALL_LIKE_HPUX
  float qnan ()
#endif

#if defined (VMS) || CALL_LIKE_STARDENT
  float QNAN ()
#endif

#if CALL_LIKE_SUN
  float qnan_ ()
#endif

#if CALL_LIKE_IRIS
  float qnan_ ()
#endif
@ We have a choice of \idx{NaN} values in \ac{ieee} arithmetic.
[[0xfffa5a5a]] is the one used by the \idx{MIPS} compilers as an
undefined value.
<<magic numbers>>=
#ifdef DF_MT == DFMT_BEIEEE
  NAN = 0xfffa5a5a;
#endif
#ifdef DF_MT == DFMT_LEIEEE
  NAN = 0x5a5afaff;
#endif
@ For \idx{Convex} native mode and \idx{VAX} use a \idx{Rop} value:
<<magic numbers>>=
#ifdef DF_MT == DFMT_CONVEXNATIVE
  NAN = 0x80000000;
#endif
#ifdef DF_MT == DFMT_VAX
  NAN = 0x00008000;
#endif
  union float_uint_uchar NaNvalue.i = NAN;
{
  return NaNvalue.f;
}
@ \subsection{Testing a value: {\tt int cisnan(\meta{real})}}

We want a \ft{} logical function [[qnan]] to test whether its argument
is a \idx{NaN} or \idx{Rop}.  We have to do this by writing a C
[[float]]-valued procedure and testing the returned value in the \ft{}
so that we don't have to assume how it represents logical values.  The
{\tt diskio}\index{diskio@{\tt diskio}} library module provides the
trivial interface [[QISNAN]].
<<magic numbers>>=
#if CALL_LIKE_HPUX
  int cisnan (real)
#endif
#if defined (VMS) || CALL_LIKE_STARDENT
  int CISNAN (real)
#endif
#if CALL_LIKE_SUN
  int cisnan_ (real)
#endif
#if CALL_LIKE_IRIS
  int cisnan_ (real)
#endif
  float_uint_uchar real;
{
  unsigned char exponent;
  switch (userFT) {
@ In the \ac{ieee} case we actually return true both for \idx{NaN}s
and for \idx{Infinity}.
<<magic numbers>>=
  case DFNTF_BEIEEE :
    return (((real.i & 0x7f800000)
             == 0x7f800000)     /* exponent all 1s */
            && ((real.i & 0x007fffff)
                == 0));         /* non-zero fraction */
  case DFNTF_LEIEEE :
    return (((real.i & 0x0000807f)
             == 0x0000807f)     /* exponent all 1s */
            && ((real.i & 0xffff7f00)
                == 0));         /* non-zero fraction */
@ \idx{VAX} and \idx{Convex} \idx{Rop} has sign $=1$ and zero exponent
with the appropriate byte sex---bit 15 and bits 7--14 respectively in
the appropriate half-word.
<<magic numbers>>=
  case DFNTF_CONVEXNATIVE :
    return ((real.i & 0xff800000) == 0x80000000);      
  case DFNTF_VAX :
    return ((real.i & 0x0000ff80) == 0x00008000);
  default :
    fatal("QREAD: bad file type in conversion");  }
}

@ \makeatletter\printindex

\end{document}
